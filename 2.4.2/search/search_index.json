{
    "docs": [
        {
            "location": "/", 
            "text": "How does fabalicious work in two sentences\n\n\nFabalicious uses a configuration file with a list of hosts and \nssh\n and optionally tools like \ncomposer\n, \ndrush\n, \ngit\n, \ndocker\n or custom scripts to run common tasks on remote machines. It is slightly biased to drupal-projects but it works for a lot of other types of projects.\n\n\nFabalicious is using \nfabric\n to run tasks on remote machines. The configuration-file contains a list of hosts to work on. Some common tasks are:\n\n\n\n\ndeploying new code to a remote installation\n\n\nreset a remote installation to its defaults.\n\n\nbackup/ restore data\n\n\ncopy data from one installation to another\n\n\noptionally work with our docker-based development-stack \nmultibasebox", 
            "title": "How does fabalicious work in two sentences"
        }, 
        {
            "location": "/#how-does-fabalicious-work-in-two-sentences", 
            "text": "Fabalicious uses a configuration file with a list of hosts and  ssh  and optionally tools like  composer ,  drush ,  git ,  docker  or custom scripts to run common tasks on remote machines. It is slightly biased to drupal-projects but it works for a lot of other types of projects.  Fabalicious is using  fabric  to run tasks on remote machines. The configuration-file contains a list of hosts to work on. Some common tasks are:   deploying new code to a remote installation  reset a remote installation to its defaults.  backup/ restore data  copy data from one installation to another  optionally work with our docker-based development-stack  multibasebox", 
            "title": "How does fabalicious work in two sentences"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation of needed dependencies\n\n\nfabalicious needs fabric 1.x, which dependes on python 2.x.\n\n\non Mac OS X:\n\n\nbrew install python2 # not necessarily needed, you can try to use mac's native python\npip install \"fabric\n2.0\"\npip install pyyaml\n\n\n\non Debian/Ubuntu\n\n\napt-get install python-pip\npip install \"fabric\n2.0\"\npip install pyyaml\n\n\n\nIf you want to use the slack-integration, install slacker, but it's optional.\n\n\npip install slacker\n\n\n\nCreate a file called \"fabfile.yaml\" and add your hosts to this file. See this file for more information.\n\n\nInstallation of fabalicious\n\n\nThere are 2 alternative ways to install fabalicious. Because of historic reasons we install fabalicious into the folder \n_tools/fabalicious\n\n\nas git-submodule\n\n\nClone this repository, or add this repository as a submodule.\n\n\nmkdir _tools/fabalicious\ngit submodule add https://github.com/factorial-io/fabalicious.git _tools/fabalicious\nln -s _tools/fabalicious/fabfile.py fabfile.py\n\n\n\n\nas composer dependency\n\n\nIf you are using composer you can add fabalicious as a dependency\n\n\ncomposer require factorial-io/fabalicious 2.*\nComposer install\n\n\n\n\nand then ...\n\n\n\n\nRun \nfab --list\n, this should give you a list of available commands.\n\n\nCreate a configuration file called \nfabfile.yaml\n\n\n\n\nA simple configuration-example\n\n\nname: My awesome project\n\n# We'll need fabalicious \n= 2.0\nrequires: 2.0\n\n# We need git and ssh, there are more options\nneeds:\n  - ssh\n  - git\n\n# Our list of host-configurations\nhosts:\n  dev:\n    host: myhost.dev\n    user: root\n    port: 22\n    type: dev\n    branch: develop\n    rootFolder: /var/www\n    filesFolder: /var/www\n    siteFolder: /var/www\n    backupFolder: /var/backups\n\n\n\n\nFor more infos about the file-format have a look at the file-format-section.\n\n\nGeneral notes regarding MAMP usage\n\n\nMake sure that the local instances of PHP and mysql are the actual MAMP binaries:\n\n\n$ sudo ln -s /Applications/MAMP/Library/bin/mysql /usr/local/bin/mysql\n\n\nAdd the correct php binary to your .zshrc / .bashrc\n\n\n$ export DRUSH_PHP=/Applications/MAMP/bin/php/php7.0.12/bin/php", 
            "title": "Installation of needed dependencies"
        }, 
        {
            "location": "/installation/#installation-of-needed-dependencies", 
            "text": "fabalicious needs fabric 1.x, which dependes on python 2.x.  on Mac OS X:  brew install python2 # not necessarily needed, you can try to use mac's native python\npip install \"fabric 2.0\"\npip install pyyaml  on Debian/Ubuntu  apt-get install python-pip\npip install \"fabric 2.0\"\npip install pyyaml  If you want to use the slack-integration, install slacker, but it's optional.  pip install slacker  Create a file called \"fabfile.yaml\" and add your hosts to this file. See this file for more information.", 
            "title": "Installation of needed dependencies"
        }, 
        {
            "location": "/installation/#installation-of-fabalicious", 
            "text": "There are 2 alternative ways to install fabalicious. Because of historic reasons we install fabalicious into the folder  _tools/fabalicious", 
            "title": "Installation of fabalicious"
        }, 
        {
            "location": "/installation/#as-git-submodule", 
            "text": "Clone this repository, or add this repository as a submodule.  mkdir _tools/fabalicious\ngit submodule add https://github.com/factorial-io/fabalicious.git _tools/fabalicious\nln -s _tools/fabalicious/fabfile.py fabfile.py", 
            "title": "as git-submodule"
        }, 
        {
            "location": "/installation/#as-composer-dependency", 
            "text": "If you are using composer you can add fabalicious as a dependency  composer require factorial-io/fabalicious 2.*\nComposer install", 
            "title": "as composer dependency"
        }, 
        {
            "location": "/installation/#and-then", 
            "text": "Run  fab --list , this should give you a list of available commands.  Create a configuration file called  fabfile.yaml", 
            "title": "and then ..."
        }, 
        {
            "location": "/installation/#a-simple-configuration-example", 
            "text": "name: My awesome project\n\n# We'll need fabalicious  = 2.0\nrequires: 2.0\n\n# We need git and ssh, there are more options\nneeds:\n  - ssh\n  - git\n\n# Our list of host-configurations\nhosts:\n  dev:\n    host: myhost.dev\n    user: root\n    port: 22\n    type: dev\n    branch: develop\n    rootFolder: /var/www\n    filesFolder: /var/www\n    siteFolder: /var/www\n    backupFolder: /var/backups  For more infos about the file-format have a look at the file-format-section.", 
            "title": "A simple configuration-example"
        }, 
        {
            "location": "/installation/#general-notes-regarding-mamp-usage", 
            "text": "Make sure that the local instances of PHP and mysql are the actual MAMP binaries:  $ sudo ln -s /Applications/MAMP/Library/bin/mysql /usr/local/bin/mysql  Add the correct php binary to your .zshrc / .bashrc  $ export DRUSH_PHP=/Applications/MAMP/bin/php/php7.0.12/bin/php", 
            "title": "General notes regarding MAMP usage"
        }, 
        {
            "location": "/usage/", 
            "text": "Running fabalicious\n\n\nTo execute a task with the help of fabalicious, just\n\n\ncd \nyour-project-folder\n\nfab config:\nyour-config-key\n \ntask\n\n\n\n\n\nThis will read your fabfile.yaml, look for \nyour-config-key\n in the host-section and run the task \n\n\nTasks\n\n\nSome Background\n\n\nFabalicious provides a set of so-called methods which implement all listed functionality. The following methods are available:\n\n\n\n\ngit\n\n\nssh\n\n\ndrush\n\n\ncomposer\n\n\nfiles\n\n\ndocker\n\n\ndrupalconsole\n\n\nslack\n\n\nplatform\n\n\n\n\nYou declare your needs in the fabfile.yaml with the key \nneeds\n, e.g.\n\n\nneeds:\n  - git\n  - ssh\n  - drush\n  - files\n\n\n\n\nHave a look at the file-format documentation for more info.\n\n\nList of available tasks\n\n\nYou can get a list of available commands with\n\n\nfab --list", 
            "title": "Running fabalicious"
        }, 
        {
            "location": "/usage/#running-fabalicious", 
            "text": "To execute a task with the help of fabalicious, just  cd  your-project-folder \nfab config: your-config-key   task   This will read your fabfile.yaml, look for  your-config-key  in the host-section and run the task", 
            "title": "Running fabalicious"
        }, 
        {
            "location": "/usage/#tasks", 
            "text": "", 
            "title": "Tasks"
        }, 
        {
            "location": "/usage/#some-background", 
            "text": "Fabalicious provides a set of so-called methods which implement all listed functionality. The following methods are available:   git  ssh  drush  composer  files  docker  drupalconsole  slack  platform   You declare your needs in the fabfile.yaml with the key  needs , e.g.  needs:\n  - git\n  - ssh\n  - drush\n  - files  Have a look at the file-format documentation for more info.", 
            "title": "Some Background"
        }, 
        {
            "location": "/usage/#list-of-available-tasks", 
            "text": "You can get a list of available commands with  fab --list", 
            "title": "List of available tasks"
        }, 
        {
            "location": "/available-tasks/", 
            "text": "config\n\n\nfab config:\nyour-config\n\n\n\n\n\nThis is one of the most fundamental commands fabalicious provides. This will lookup \nyour-config\n in the \nhosts\n-section of your \nfabfile.yaml\n and feed the data to \nfabric\n so it can connect to the host.\n\n\nlist\n\n\nfab list\n\n\n\n\nThis task will list all your hosts defined in your \nhosts\n-section of your \nfabfile.yaml\n.\n\n\nabout\n\n\nfab config:\nyour-config\n about\n\n\n\n\nwill display the configuration of host \nyour-config\n.\n\n\noffline\n\n\nfab offline config:\nyour-config\n \ntask\n\n\n\n\n\nThis task will disable remote configuration files. As fabalicious keeps copies of remote configuration-files in \n~/.fabalicious\n it will try to load the configuration-file from there.\n\n\nblueprint\n\n\nfab config:\nyour-config\n blueprint:\nbranch-name\n\nfab blueprint:\nbranch-name\n,configName=\nconfig-name\n\nfab blueprint:\nbranch-name\n,configNmae=\nconfig-name\n,output=True\n\n\n\n\nblueprint\n will try to load a blueprint-template from the fabfile.yaml and apply the input given as \nbranch-name\n to the template. This is helpful if you want to create/ use a new configuration which has some dynamic parts like the name of the database, the name of the docker-container, etc.\n\n\nThe task will look first in the host-config for the property \nblueprint\n, afterwards in the dockerHost-configuration \nconfig-name\n and eventually in the global namespace. If you wnat to print the generated configuration as yaml, then add \n,output=true\n to the command. If not, the generated configuration is used as the current configuration, that means, you can run other tasks against the generated configuration.\n\n\nAvailable replacement-patterns\n and what they do.\n\n\nInput is \nfeature/XY-123-my_Branch-name\n, the project-name is \nExample project\n\n\n\n\n\n\n\n\nReplacement Pattern\n\n\nvalue\n\n\n\n\n\n\n\n\n\n\n%slug.with-hyphens.without-feature%\n\n\nxy-123-my-branch-name\n\n\n\n\n\n\n%slug.with-hyphens%\n\n\nfeature-xy-123-my-branch-name\n\n\n\n\n\n\n%project-slug.with-hypens%\n\n\nexample-project\n\n\n\n\n\n\n%slug%\n\n\nfeaturexy123mybranchname\n\n\n\n\n\n\n%project-slug%\n\n\nexampleproject\n\n\n\n\n\n\n%project-identifier%\n\n\nExample project\n\n\n\n\n\n\n%identifier%\n\n\nfeature/XY-123-my_Branch-name\n\n\n\n\n\n\n%slug.without-feature%\n\n\nxy123mybranchname\n\n\n\n\n\n\n\n\nHere's an example blueprint:\n\n\nblueprint:\n  inheritsFrom: http://some.host/data.yaml\n  configName: '%project-slug%-%slug.with-hyphens.without-feature%.some.host.tld'\n  branch: '%identifier%'\n  database:\n    name: '%slug.without-feature%_mysql'\n  docker:\n    projectFolder: '%project-slug%--%slug.with-hyphens.without-feature%'\n    vhost: '%project-slug%-%slug.without-feature%.some.host.tld'\n    name: '%project-slug%%slug.without-feature%_web_1'\n\n\n\n\nAnd the output of \nfab blueprint:feature/XY-123-my_Branch-name,configNamy=\nconfig-name\n,output=true\n is\n\n\nhosts:\n  phbackend-xy-123-my-branch-name.some.host.tld:\n    branch: feature/XY-123-my_Branch-name\n    configName: phbackend-xy-123-my-branch-name.some.host.tld\n    database:\n      name: xy123mybranchname_mysql\n    docker:\n      name: phbackendxy123mybranchname_web_1\n      projectFolder: phbackend--xy-123-my-branch-name\n      vhost: phbackend-xy123mybranchname.some.host.tld\n    inheritsFrom: http://some.host/data.yaml\n\n\n\n\nNote\n\n\nYou can create new configurations via the global \nblueprints\n-settings:\n\n\nblueprints:\n  - configName: mbb\n    variants:\n      - de\n      - en\n      - it\n      - fr\n\n\n\n\nwill create 4 new configurations using the blueprint-config \nmbb\n.\n\n\ndoctor\n\n\nThe \ndoctor\n-task will try to establish all needed ssh-connections and tunnels and give feedback if anything fails. This should be the task you run if you have any problems connecting to a remote instance.\n\n\nfab config:\nyour-config\n doctor\nfab config:\nyour-config\n doctor:remote=\nyour-remote-config\n\n\n\n\n\nRunning the doctor-task without an argument, will test the connectivity to the configuration \nyour-cofig\n. If you provide a remote configuration with \n:remote=\nyour-remote-config\n the doctor command will create and test any necessary tunnels to test the connections betwenn \nyour-config\n and \nyour-remote-config\n. Might be handy if the task \ncopyFrom\n fails.\n\n\ngetProperty\n\n\nfab config:\nyour-config\n getProperty:\nname-of-property\n\n\n\n\n\nThis will print the property-value to the console. Suitable if you want to use fabalicious from within other scripts.\n\n\nExamples\n\n\n\n\nfab config:mbb getProperty:host\n will print the hostname of configuration \nmbb\n.\n\n\nfab config:mbb getProperty:docker/tag\n will print the tag of the docker-configuration of \nmbb\n.\n\n\n\n\nversion\n\n\nfab config:\nyour-config\n version\n\n\n\n\nThis command will display the installed version of the code on the installation \nyour-config\n.\n\n\nAvailable methods\n:\n\n\n\n\ngit\n. The task will get the installed version via \ngit describe\n, so if you tag your source properly (hint git flow), you'll get a nice version-number.\n\n\n\n\nConfiguration:\n\n\n\n\nyour host-configuration needs a \nbranch\n-key stating the branch to deploy.\n\n\n\n\ndeploy\n\n\nfab config:\nyour-config\n deploy\nfab config:\nyour-config\n deploy:\nbranch-to-deploy\n\n\n\n\n\nThis task will deploy the latest code to the given installation. If the installation-type is not \ndev\n or \ntest\n the \nbackupDB\n-task is run before the deployment starts. If \nbranch-to-deploy\n is stated the specific branch gets deployed.\n\n\nAfter a successfull deployment the \nreset\n-taks will be run.\n\n\nAvailable methods:\n\n\n\n\ngit\n will deploy to the latest commit for the given branch defined in the host-configuration. Submodules will be synced, and updated.\n\n\nplatform\n will push the current branch to the \nplatform\n remote, which will start the deployment-process on platform.sh\n\n\n\n\nConfiguration:\n\n\n\n\nyour host-configuration needs a \nbranch\n-key stating the branch to deploy.\n\n\n\n\nreset\n\n\nfab config:\nyour-config\n reset\n\n\n\n\nThis task will reset your installation\n\n\nAvailable methods:\n\n\n\n\ncomposer\n will run \ncomposer install\n to update any dependencies before doing the reset\n\n\ndrush\n will\n\n\nset the site-uuid from fabfile.yaml (drupal 8)\n\n\nenable the deployment-module\n\n\nenable modules listed in file \nmodules_enabled.txt\n\n\ndisable modules listed in file \nmodules_disabled.txt\n\n\nrevert features (drupal 7) if \nrevertFeatures\n is true / import the configuration \nstaging\n (drupal 8),\n\n\nrun update-hooks\n\n\nenable a deployment-module if any stated in the fabfile.yaml\n\n\nand does a cache-clear.\n\n\nif your host-type is \ndev\n and \nwithPasswordReset\n is not false, the password gets reset to admin/admin\n\n\n\n\nConfiguration:\n\n\n\n\nyour host-configuration needs a \nbranch\n-key stating the branch to deploy.\n\n\nyour configuration needs a \nuuid\n-entry, this is the site uuid (drupal 8). You can get the site-uuid via \ndrush cget system.site\n\n\nyou can customize which configuration to import with the \nconfigurationManagement\n-setting inside your host- or global-setting.\n\n\n\n\nExamples:\n\n\n\n\nfab config:mbb reset:withPasswordReset=0\n will reset the installation and will not reset the password.\n\n\n\n\ninstall\n\n\nfab config:\nyour-config\n install\nfab config:\nyour-config\n install,distribution=thunder\nfab config:\nyour-config\n install,locale=de\n\n\n\n\nThis task will install a new Drupal installation with the minimal-distribution. You can install different distributions, see the examples.\n\n\nAvailable methods:\n\n\n\n\ndrush7\n and \ndrush8\n\n\n\n\nConfiguration:\n\n\nAs an alternative you can add a \ninstallOptions\n-section to your fabfile.yaml. Here's an example:\n\n\ninstallOptions:\n  distribution: thunder\n  locale: es\n\n\n\n\nOptions via command line will override the settings in your fabfile.yaml.\n\n\ninstallFrom\n\n\nfab config:\nyour-config\n installFrom:\nsource-config\n\n\n\n\n\nThis task will install a new installation (see the \ninstall\n-task) and afterwards will do a \ncopyFrom\n. The \nreset\n-task after the \ninstall\n-task will be skipped and executed after the \ncopyFrom\n-task.\n\n\nSee also:\n\n\n\n\ninstall\n\n\ncopyFrom\n\n\n\n\nbackup\n\n\nfab config:\nyour-config\n backup\n\n\n\n\nThis command will backup your files and database into the specified \nbackup\n-directory. The file-names will include configuration-name, a timestamp and the git-SHA1. Every backup can be referenced by its filename (w/o extension) or, when git is abailable via the git-commit-hash.\n\n\nAvailable methods:\n\n\n\n\ngit\n will prepend the file-names with a hash of the current revision.\n\n\nfiles\n will tar all files in the \nfilesFolder\n and save it into the \nbackupFolder\n\n\ndrush\n will dump the databases and save it to the \nbackupFolder\n\n\n\n\nConfiguration:\n\n\n\n\nyour host-configuration will need a \nbackupFolder\n and a \nfilesFolder\n\n\n\n\nbackupDB\n\n\nfab config:\nyour-config\n backupDB\n\n\n\n\nThis command will backup only the database. See the task \nbackup\n for more info.\n\n\nlistBackups\n\n\nfab config:\nyour-config\n listBackups\n\n\n\n\nThis command will print all available backups to the console.\n\n\nrestore\n\n\nfab config:\nyour-config\n restore:\ncommit-hash|file-name\n\n\n\n\n\nThis will restore a backup-set. A backup-set consists typically of a database-dump and a gzupped-file-archive. You can a list of candidates via \nfab config:\nconfig\n listBackups\n\n\nAvailable methods\n\n\n\n\ngit\n git will checkout the given hash encoded in the filename.\n\n\nfiles\n all files will be restored. An existing files-folder will be renamed for safety reasons.\n\n\ndrush\n will import the database-dump.\n\n\n\n\ngetBackup\n\n\nfab config:\nconfig\n getBackup:\ncommit-hash|file-name\n\n\n\n\n\nThis command will copy a remote backup-set to your local computer into the current working-directory.\n\n\nSee also:\n\n\n\n\nrestore\n\n\nbackup\n\n\n\n\ncopyFrom\n\n\nfab config:\ndest-config\n copyFrom:\nsource-config\n\n\n\n\n\nThis task will copy all files via rsync from \nsource-config\nto \ndest-config\n and will dump the database from \nsource-config\n and restore it to \ndest-config\n. After that the \nreset\n-task gets executed. This is the ideal task to copy a complete installation from one host to another.\n\n\nAvailable methods\n\n\n\n\nssh\n will create all necessary tunnels to access the hosts.\n\n\nfiles\n will rsync all new and changed files from source to dest\n\n\ndrush\n will dump the database and restore it on the dest-host.\n\n\n\n\ncopyDBFrom\n\n\nfab config:\ndest-config\n copyDBFrom:\nsource-config\n\n\n\n\n\nBasically the same as the \ncopyFrom\n-task, but only the database gets copied.\n\n\ncopyFilesFrom\n\n\nfab config:\ndest-config\n copyFileFrom:\nsource-config\n\n\n\n\n\nBasically the same as the \ncopyFrom\n-task, but only the new and updated files get copied.\n\n\ndrush\n\n\nfab config:\nconfig\n drush:\ndrush-command\n\n\n\n\n\nThis task will execute the \ndrush-command\n on the remote host specified in \n. Please note, that you'll have to quote the drush-command when it contains spaces. Signs should be excaped, so python does not interpret them.\n\n\nAvailable methods\n\n\n\n\nOnly available for the \ndrush\n-method\n\n\n\n\nExamples\n\n\n\n\nfab config:staging drush:\"cc all\"\n\n\nfab config:local drush:fra\n\n\n\n\ndrupalconsole\n\n\nThis task will execute a drupal-console task on the remote host. Please note, that you'll have to quote the command when it contains spaces. There's a special command to install the drupal-console on the host: \nfab config:\nconfig\n drupalconsole:install\n\n\nAvailable methods\n\n\n\n\nOnly available for the \ndrupalconsole\n-method\n\n\n\n\nExamples\n\n\n\n\nfab config:local drupalconsole:cache:rebuild\n\n\nfab config:local drupalconsole:\"generate:module --module helloworld\"\n\n\n\n\ngetFile\n\n\nfab config:\nconfig\n getFile:\npath-to-remote-file\n\n\n\n\n\nCopy a remote file to the current working directory of your current machine.\n\n\nputFile\n\n\nfab config:\nconfig\n putFile:\npath-to-local-file\n\n\n\n\n\nCopy a local file to the tmp-folder of a remote machine.\n\n\nConfiguration\n\n\n\n\nthis command will use the \ntmpFolder\n-host-setting for the destination directory.\n\n\n\n\ngetFilesDump\n\n\nfab config:\nconfig\n getFilesDump\n\n\n\n\nThis task will tar all files in \nfilesFolder\n and \nprivateFilesFolder\n and download it to the local computer.\n\n\nAvailable methods\n\n\n\n\ncurrently only implemented for the \nfiles\n-method\n\n\n\n\ngetSQLDump\n\n\nfab config:\nconfig\n getSQLDump\n\n\n\n\nGet a current dump of the remote database and copy it to the local machine into the current working directory.\n\n\nAvailable methods\n\n\n\n\ncurrently only implemented for the \ndrush\n-method\n\n\n\n\nrestoreSQLFromFile\n\n\nfab config:\nconfig\n restoreSQLFromFile:\npath-to-local-sql-dump\n\n\n\n\n\nThis command will copy the dump-file \npath-to-local-sql-dump\n to the remote machine and import it into the database.\n\n\nAvailable methods\n\n\n\n\ncurrently only implemented for the \ndrush\n-method\n\n\n\n\nscript\n\n\nfab config:\nconfig\n script:\nscript-name\n\n\n\n\n\nThis command will run custom scripts on a remote machine. You can declare scripts globally or per host. If the \nscript-name\n can't be found in the fabfile.yaml you'll get a list of all available scripts.\n\n\nAdditional arguments get passed to the script. You'll have to use the python-syntax to feed additional arguments to the script. See the examples.\n\n\nExamples\n\n\n\n\nfab config:mbb script\n. List all available scripts for configuration \nmbb\n\n\nfab config:mbb script:behat\n Run the \nbehat\n-script\n\n\nfab config:mbb script:behat,--name=\"Login feature\",--format=pretty\n Run the behat-test, apply \n--name\n and \n--format\n parameters to the script\n\n\n\n\nThe \nscript\n-command is rather powerful, have a read about it in the extra section.\n\n\ndocker\n\n\nfab config:\nconfig\n docker:\ndocker-task\n\n\n\n\n\nThe docker command is suitable for orchestrating and administering remote instances of docker-containers. The basic setup is that your host-configuration has a \ndocker\n-section, which contains a \nconfiguration\n-key. The \ndockerHosts\n-section of your fabfile.yaml has a list of tasks which are executed on the \"parent-host\" of the configuration. Please have a look at the docker-section for more information.\n\n\nMost of the time the docker-container do not have a public or known ip-address. Fabalicious tries to find out the ip-address of a given instance and use that for communicating with its services.\n\n\nThere are three implicit tasks available:\n\n\ncopySSHKeys\n\n\nfab config:mbb docker:copySSHKeys\n\n\n\n\nThis will copy the ssh-keys into the docker-instance. You'll need to provide the paths to the files via the three configurations:\n\n \ndockerKeyFile\n, the path to the private ssh-key to use.\n\n \ndockerAuthorizedKeyFile\n, the path to the file for \nauthoried_keys\n\n* \ndockerKnownHostsFile\n, the path to the file for \nknown_hosts\n\n\nAs docker-container do not have any state, this task is used to copy any necessary ssh-configuration into the docker-container, so communication per ssh does not need any passwords.\n\n\nstartRemoteAccess\n\n\nfab config:\nconfig\n docker:startRemoteAccess\nfab config:\nconfig\n docker:startRemoteAccess,port=\nport\n,publicPort=\npublic-port\n\n\n\n\n\nThis docker-task will run a ssh-command to forward a local port to a port inside the docker-container. It starts a new ssh-session which will do the forwarding. When finished, type \nexit\n.\n\n\nExamples\n\n\n\n\nfab config:mbb docker:startRemoteAccess\n will forward \nlocalhost:8888\n to port \n80\n of the docker-container\n\n\nfab config:mbb docker:startRemoteAccess,port=3306,publicPort=33060\n will forward \nlocalhost:33060\nto port \n3306\n of the docker-container\n\n\n\n\nwaitForServices\n\n\nThis task will try to establish a ssh-connection into the docker-container and if the connection succeeds, waits for \nsupervisorctl status\n to return success. This is useful in scripts to wait for any services that need some time to start up. Obviously this task depends on \nsupervisorctl\n.\n\n\nlogLevel\n\n\nCan be used to override default logging level used by fabalicious.\nAvailable values :\n\n\n\n\nDEBUG\n\n\nINFO\n\n\nWARNING\n\n\nERROR\n\n\nCRITICAL\n\n\n\n\nExamples\n\n\n\n\nfab logLevel:DEBUG config:mbb ssh\n will start outputting DEBUG level messages.", 
            "title": "Available tasks"
        }, 
        {
            "location": "/available-tasks/#config", 
            "text": "fab config: your-config   This is one of the most fundamental commands fabalicious provides. This will lookup  your-config  in the  hosts -section of your  fabfile.yaml  and feed the data to  fabric  so it can connect to the host.", 
            "title": "config"
        }, 
        {
            "location": "/available-tasks/#list", 
            "text": "fab list  This task will list all your hosts defined in your  hosts -section of your  fabfile.yaml .", 
            "title": "list"
        }, 
        {
            "location": "/available-tasks/#about", 
            "text": "fab config: your-config  about  will display the configuration of host  your-config .", 
            "title": "about"
        }, 
        {
            "location": "/available-tasks/#offline", 
            "text": "fab offline config: your-config   task   This task will disable remote configuration files. As fabalicious keeps copies of remote configuration-files in  ~/.fabalicious  it will try to load the configuration-file from there.", 
            "title": "offline"
        }, 
        {
            "location": "/available-tasks/#blueprint", 
            "text": "fab config: your-config  blueprint: branch-name \nfab blueprint: branch-name ,configName= config-name \nfab blueprint: branch-name ,configNmae= config-name ,output=True  blueprint  will try to load a blueprint-template from the fabfile.yaml and apply the input given as  branch-name  to the template. This is helpful if you want to create/ use a new configuration which has some dynamic parts like the name of the database, the name of the docker-container, etc.  The task will look first in the host-config for the property  blueprint , afterwards in the dockerHost-configuration  config-name  and eventually in the global namespace. If you wnat to print the generated configuration as yaml, then add  ,output=true  to the command. If not, the generated configuration is used as the current configuration, that means, you can run other tasks against the generated configuration.  Available replacement-patterns  and what they do.  Input is  feature/XY-123-my_Branch-name , the project-name is  Example project     Replacement Pattern  value      %slug.with-hyphens.without-feature%  xy-123-my-branch-name    %slug.with-hyphens%  feature-xy-123-my-branch-name    %project-slug.with-hypens%  example-project    %slug%  featurexy123mybranchname    %project-slug%  exampleproject    %project-identifier%  Example project    %identifier%  feature/XY-123-my_Branch-name    %slug.without-feature%  xy123mybranchname     Here's an example blueprint:  blueprint:\n  inheritsFrom: http://some.host/data.yaml\n  configName: '%project-slug%-%slug.with-hyphens.without-feature%.some.host.tld'\n  branch: '%identifier%'\n  database:\n    name: '%slug.without-feature%_mysql'\n  docker:\n    projectFolder: '%project-slug%--%slug.with-hyphens.without-feature%'\n    vhost: '%project-slug%-%slug.without-feature%.some.host.tld'\n    name: '%project-slug%%slug.without-feature%_web_1'  And the output of  fab blueprint:feature/XY-123-my_Branch-name,configNamy= config-name ,output=true  is  hosts:\n  phbackend-xy-123-my-branch-name.some.host.tld:\n    branch: feature/XY-123-my_Branch-name\n    configName: phbackend-xy-123-my-branch-name.some.host.tld\n    database:\n      name: xy123mybranchname_mysql\n    docker:\n      name: phbackendxy123mybranchname_web_1\n      projectFolder: phbackend--xy-123-my-branch-name\n      vhost: phbackend-xy123mybranchname.some.host.tld\n    inheritsFrom: http://some.host/data.yaml  Note  You can create new configurations via the global  blueprints -settings:  blueprints:\n  - configName: mbb\n    variants:\n      - de\n      - en\n      - it\n      - fr  will create 4 new configurations using the blueprint-config  mbb .", 
            "title": "blueprint"
        }, 
        {
            "location": "/available-tasks/#doctor", 
            "text": "The  doctor -task will try to establish all needed ssh-connections and tunnels and give feedback if anything fails. This should be the task you run if you have any problems connecting to a remote instance.  fab config: your-config  doctor\nfab config: your-config  doctor:remote= your-remote-config   Running the doctor-task without an argument, will test the connectivity to the configuration  your-cofig . If you provide a remote configuration with  :remote= your-remote-config  the doctor command will create and test any necessary tunnels to test the connections betwenn  your-config  and  your-remote-config . Might be handy if the task  copyFrom  fails.", 
            "title": "doctor"
        }, 
        {
            "location": "/available-tasks/#getproperty", 
            "text": "fab config: your-config  getProperty: name-of-property   This will print the property-value to the console. Suitable if you want to use fabalicious from within other scripts.  Examples   fab config:mbb getProperty:host  will print the hostname of configuration  mbb .  fab config:mbb getProperty:docker/tag  will print the tag of the docker-configuration of  mbb .", 
            "title": "getProperty"
        }, 
        {
            "location": "/available-tasks/#version", 
            "text": "fab config: your-config  version  This command will display the installed version of the code on the installation  your-config .  Available methods :   git . The task will get the installed version via  git describe , so if you tag your source properly (hint git flow), you'll get a nice version-number.   Configuration:   your host-configuration needs a  branch -key stating the branch to deploy.", 
            "title": "version"
        }, 
        {
            "location": "/available-tasks/#deploy", 
            "text": "fab config: your-config  deploy\nfab config: your-config  deploy: branch-to-deploy   This task will deploy the latest code to the given installation. If the installation-type is not  dev  or  test  the  backupDB -task is run before the deployment starts. If  branch-to-deploy  is stated the specific branch gets deployed.  After a successfull deployment the  reset -taks will be run.  Available methods:   git  will deploy to the latest commit for the given branch defined in the host-configuration. Submodules will be synced, and updated.  platform  will push the current branch to the  platform  remote, which will start the deployment-process on platform.sh   Configuration:   your host-configuration needs a  branch -key stating the branch to deploy.", 
            "title": "deploy"
        }, 
        {
            "location": "/available-tasks/#reset", 
            "text": "fab config: your-config  reset  This task will reset your installation  Available methods:   composer  will run  composer install  to update any dependencies before doing the reset  drush  will  set the site-uuid from fabfile.yaml (drupal 8)  enable the deployment-module  enable modules listed in file  modules_enabled.txt  disable modules listed in file  modules_disabled.txt  revert features (drupal 7) if  revertFeatures  is true / import the configuration  staging  (drupal 8),  run update-hooks  enable a deployment-module if any stated in the fabfile.yaml  and does a cache-clear.  if your host-type is  dev  and  withPasswordReset  is not false, the password gets reset to admin/admin   Configuration:   your host-configuration needs a  branch -key stating the branch to deploy.  your configuration needs a  uuid -entry, this is the site uuid (drupal 8). You can get the site-uuid via  drush cget system.site  you can customize which configuration to import with the  configurationManagement -setting inside your host- or global-setting.   Examples:   fab config:mbb reset:withPasswordReset=0  will reset the installation and will not reset the password.", 
            "title": "reset"
        }, 
        {
            "location": "/available-tasks/#install", 
            "text": "fab config: your-config  install\nfab config: your-config  install,distribution=thunder\nfab config: your-config  install,locale=de  This task will install a new Drupal installation with the minimal-distribution. You can install different distributions, see the examples.  Available methods:   drush7  and  drush8   Configuration:  As an alternative you can add a  installOptions -section to your fabfile.yaml. Here's an example:  installOptions:\n  distribution: thunder\n  locale: es  Options via command line will override the settings in your fabfile.yaml.", 
            "title": "install"
        }, 
        {
            "location": "/available-tasks/#installfrom", 
            "text": "fab config: your-config  installFrom: source-config   This task will install a new installation (see the  install -task) and afterwards will do a  copyFrom . The  reset -task after the  install -task will be skipped and executed after the  copyFrom -task.  See also:   install  copyFrom", 
            "title": "installFrom"
        }, 
        {
            "location": "/available-tasks/#backup", 
            "text": "fab config: your-config  backup  This command will backup your files and database into the specified  backup -directory. The file-names will include configuration-name, a timestamp and the git-SHA1. Every backup can be referenced by its filename (w/o extension) or, when git is abailable via the git-commit-hash.  Available methods:   git  will prepend the file-names with a hash of the current revision.  files  will tar all files in the  filesFolder  and save it into the  backupFolder  drush  will dump the databases and save it to the  backupFolder   Configuration:   your host-configuration will need a  backupFolder  and a  filesFolder", 
            "title": "backup"
        }, 
        {
            "location": "/available-tasks/#backupdb", 
            "text": "fab config: your-config  backupDB  This command will backup only the database. See the task  backup  for more info.", 
            "title": "backupDB"
        }, 
        {
            "location": "/available-tasks/#listbackups", 
            "text": "fab config: your-config  listBackups  This command will print all available backups to the console.", 
            "title": "listBackups"
        }, 
        {
            "location": "/available-tasks/#restore", 
            "text": "fab config: your-config  restore: commit-hash|file-name   This will restore a backup-set. A backup-set consists typically of a database-dump and a gzupped-file-archive. You can a list of candidates via  fab config: config  listBackups  Available methods   git  git will checkout the given hash encoded in the filename.  files  all files will be restored. An existing files-folder will be renamed for safety reasons.  drush  will import the database-dump.", 
            "title": "restore"
        }, 
        {
            "location": "/available-tasks/#getbackup", 
            "text": "fab config: config  getBackup: commit-hash|file-name   This command will copy a remote backup-set to your local computer into the current working-directory.  See also:   restore  backup", 
            "title": "getBackup"
        }, 
        {
            "location": "/available-tasks/#copyfrom", 
            "text": "fab config: dest-config  copyFrom: source-config   This task will copy all files via rsync from  source-config to  dest-config  and will dump the database from  source-config  and restore it to  dest-config . After that the  reset -task gets executed. This is the ideal task to copy a complete installation from one host to another.  Available methods   ssh  will create all necessary tunnels to access the hosts.  files  will rsync all new and changed files from source to dest  drush  will dump the database and restore it on the dest-host.", 
            "title": "copyFrom"
        }, 
        {
            "location": "/available-tasks/#copydbfrom", 
            "text": "fab config: dest-config  copyDBFrom: source-config   Basically the same as the  copyFrom -task, but only the database gets copied.", 
            "title": "copyDBFrom"
        }, 
        {
            "location": "/available-tasks/#copyfilesfrom", 
            "text": "fab config: dest-config  copyFileFrom: source-config   Basically the same as the  copyFrom -task, but only the new and updated files get copied.", 
            "title": "copyFilesFrom"
        }, 
        {
            "location": "/available-tasks/#drush", 
            "text": "fab config: config  drush: drush-command   This task will execute the  drush-command  on the remote host specified in  . Please note, that you'll have to quote the drush-command when it contains spaces. Signs should be excaped, so python does not interpret them.  Available methods   Only available for the  drush -method   Examples   fab config:staging drush:\"cc all\"  fab config:local drush:fra", 
            "title": "drush"
        }, 
        {
            "location": "/available-tasks/#drupalconsole", 
            "text": "This task will execute a drupal-console task on the remote host. Please note, that you'll have to quote the command when it contains spaces. There's a special command to install the drupal-console on the host:  fab config: config  drupalconsole:install  Available methods   Only available for the  drupalconsole -method   Examples   fab config:local drupalconsole:cache:rebuild  fab config:local drupalconsole:\"generate:module --module helloworld\"", 
            "title": "drupalconsole"
        }, 
        {
            "location": "/available-tasks/#getfile", 
            "text": "fab config: config  getFile: path-to-remote-file   Copy a remote file to the current working directory of your current machine.", 
            "title": "getFile"
        }, 
        {
            "location": "/available-tasks/#putfile", 
            "text": "fab config: config  putFile: path-to-local-file   Copy a local file to the tmp-folder of a remote machine.  Configuration   this command will use the  tmpFolder -host-setting for the destination directory.", 
            "title": "putFile"
        }, 
        {
            "location": "/available-tasks/#getfilesdump", 
            "text": "fab config: config  getFilesDump  This task will tar all files in  filesFolder  and  privateFilesFolder  and download it to the local computer.  Available methods   currently only implemented for the  files -method", 
            "title": "getFilesDump"
        }, 
        {
            "location": "/available-tasks/#getsqldump", 
            "text": "fab config: config  getSQLDump  Get a current dump of the remote database and copy it to the local machine into the current working directory.  Available methods   currently only implemented for the  drush -method", 
            "title": "getSQLDump"
        }, 
        {
            "location": "/available-tasks/#restoresqlfromfile", 
            "text": "fab config: config  restoreSQLFromFile: path-to-local-sql-dump   This command will copy the dump-file  path-to-local-sql-dump  to the remote machine and import it into the database.  Available methods   currently only implemented for the  drush -method", 
            "title": "restoreSQLFromFile"
        }, 
        {
            "location": "/available-tasks/#script", 
            "text": "fab config: config  script: script-name   This command will run custom scripts on a remote machine. You can declare scripts globally or per host. If the  script-name  can't be found in the fabfile.yaml you'll get a list of all available scripts.  Additional arguments get passed to the script. You'll have to use the python-syntax to feed additional arguments to the script. See the examples.  Examples   fab config:mbb script . List all available scripts for configuration  mbb  fab config:mbb script:behat  Run the  behat -script  fab config:mbb script:behat,--name=\"Login feature\",--format=pretty  Run the behat-test, apply  --name  and  --format  parameters to the script   The  script -command is rather powerful, have a read about it in the extra section.", 
            "title": "script"
        }, 
        {
            "location": "/available-tasks/#docker", 
            "text": "fab config: config  docker: docker-task   The docker command is suitable for orchestrating and administering remote instances of docker-containers. The basic setup is that your host-configuration has a  docker -section, which contains a  configuration -key. The  dockerHosts -section of your fabfile.yaml has a list of tasks which are executed on the \"parent-host\" of the configuration. Please have a look at the docker-section for more information.  Most of the time the docker-container do not have a public or known ip-address. Fabalicious tries to find out the ip-address of a given instance and use that for communicating with its services.  There are three implicit tasks available:", 
            "title": "docker"
        }, 
        {
            "location": "/available-tasks/#copysshkeys", 
            "text": "fab config:mbb docker:copySSHKeys  This will copy the ssh-keys into the docker-instance. You'll need to provide the paths to the files via the three configurations:   dockerKeyFile , the path to the private ssh-key to use.   dockerAuthorizedKeyFile , the path to the file for  authoried_keys \n*  dockerKnownHostsFile , the path to the file for  known_hosts  As docker-container do not have any state, this task is used to copy any necessary ssh-configuration into the docker-container, so communication per ssh does not need any passwords.", 
            "title": "copySSHKeys"
        }, 
        {
            "location": "/available-tasks/#startremoteaccess", 
            "text": "fab config: config  docker:startRemoteAccess\nfab config: config  docker:startRemoteAccess,port= port ,publicPort= public-port   This docker-task will run a ssh-command to forward a local port to a port inside the docker-container. It starts a new ssh-session which will do the forwarding. When finished, type  exit .  Examples   fab config:mbb docker:startRemoteAccess  will forward  localhost:8888  to port  80  of the docker-container  fab config:mbb docker:startRemoteAccess,port=3306,publicPort=33060  will forward  localhost:33060 to port  3306  of the docker-container", 
            "title": "startRemoteAccess"
        }, 
        {
            "location": "/available-tasks/#waitforservices", 
            "text": "This task will try to establish a ssh-connection into the docker-container and if the connection succeeds, waits for  supervisorctl status  to return success. This is useful in scripts to wait for any services that need some time to start up. Obviously this task depends on  supervisorctl .", 
            "title": "waitForServices"
        }, 
        {
            "location": "/available-tasks/#loglevel", 
            "text": "Can be used to override default logging level used by fabalicious.\nAvailable values :   DEBUG  INFO  WARNING  ERROR  CRITICAL   Examples   fab logLevel:DEBUG config:mbb ssh  will start outputting DEBUG level messages.", 
            "title": "logLevel"
        }, 
        {
            "location": "/configuration/", 
            "text": "Structure of the configuration file\n\n\nOverview\n\n\nThe configuration is fetched from the file \nfabfile.yaml\n and should have the followin structure:\n\n\nname: \nthe project name\n\n\nneeds:\n  - list of methods\n\nrequires: 2.0\n\ndockerHosts:\n  docker1:\n    ...\n\nhosts:\n  host1:\n    ...\n\n\n\n\nHere's the documentation of the supported and used keys:\n\n\nname\n\n\nThe name of the project, it's only used for output.\n\n\nneeds\n\n\nList here all needed methods for that type of project. Available methods are:\n\n\n\n\ngit\n for deployments via git\n\n\nssh\n\n\ndrush7\n for support of drupal-7 installations\n\n\ndrush8\n for support fo drupal 8 installations\n\n\nfiles\n\n\nslack\n for slack-notifications\n\n\ndocker\n for docker-support\n\n\ncomposer\n for composer support\n\n\ndrupalconsole\n for drupal-concole support\n\n\n\n\nExample for drupal 7\n\n\nneeds:\n  - ssh\n  - git\n  - drush7\n  - files\n\n\n\n\nExample for drupal 8 composer based and dockerized\n\n\nneeds:\n  - ssh\n  - git\n  - drush8\n  - composer\n  - docker\n  - files\n\n\n\n\nrequires\n\n\nThe file-format of fabalicious changed over time. Set this to the lowest version of fabalicious which can handle the file. Should bei \n2.0\n\n\nhosts\n\n\nHosts is a list of host-definitions which contain all needed data to connect to a remote host. Here's an example\n\n\nhosts:\n  exampleHost:\n    host: example.host.tld\n    user: example_user\n    port: 2233\n    password: optionalPassword\n    type: dev\n    rootFolder: /var/www/public\n    gitRootFolder: /var/www\n    siteFolder: /sites/default\n    filesFolder: /sites/default/files\n    backupFolder: /var/www/backups\n    supportsInstalls: true|false\n    supportsCopyFrom: true|false\n    type: dev\n    branch: develop\n    docker:\n      ...\n    database:\n      ...\n    scripts:\n      ...\n    sshTunnel:\n      ..\n\n\n\n\n\nYou can get all host-information including the default values using the fabalicious command \nabout\n:\n\n\nfab config:staging about\n\n\n\n\nThis will print all host configuration for the host \nstaging\n.\n\n\nHere are all possible keys documented:\n\n\n\n\nhost\n, \nuser\n, \nport\n and optionally \npassword\n is used to connect via SSH to the remote machine. Please make sure SSH key forwarding is enabled on your installation. \npassword\n should only used as an exception.\n\n\ntype\n defines the type of installation. Currently there are four types available:\n\n\ndev\n for dev-installations, they won't backup the databases on deployment\n\n\ntest\n for test-installations, similar than \ndev\n, no backups on deployments\n\n\nstage\n for staging-installations.\n\n\nlive\n for live-installations. Some tasks can not be run on live-installations as \ninstall\n or as a target for \ncopyFrom\n\nThe main use-case is to run different scripts per type, see the \ncommon\n-section.\n\n\n\n\n\n\nbranch\n the name of the branch to use for deployments, they get ususally checked out and pulled from origin. \ngitRootFolder\n should be the base-folder, where the local git-repository is. (If not explicitely set, fabalicious uses the \nrootFolder\n)\n\n\nrootFolder\n  the web-root-folder of the installation, typically exposed to the public.\n\n\ngitRootFolder\n  the folder, where the git-repository lies. Defaults to \nrootFolder\n\n\ncomposerRootFolder\n the folder where the composer.json for the project is stored, defaults to \ngitRootFolder\n.\n\n\nbackupFolder\n the folder, where fabalicious should store its backups into\n\n\nrunLocally\n if set to true, all commands are run on the local host, not on a remote host. Good for local development on linux or tools like MAMP.\n\n\nsiteFolder\n is a drupal-specific folder, where the settings.php resides for the given installation. This allows to interact with multisites etc.\n\n\nfilesFolder\n the path to the files-folder, where user-assets get stored and which should be backed up by the \nfiles\n-method\n\n\ntmpFolder\n name of tmp-folder, defaults to \n/tmp\n\n\nsupportsBackups\n defaults to true, set to false, if backups are not supported\n\n\nsupportsZippedBackups\n defaults to true. Set to false, if database-dumps shouldn't be zipped.\n\n\nsupportsInstalls\n defaults to false, if set to true, the \ninstall\n-task will run on that host.\n\n\nsupportsCopyFrom\n defaults to false, if set to true, the host can be used as target for \ncopyFrom\n\n\nignoreSubmodules\n defaults to true, set to false, if you don't want to update a projects' submodule on deploy.\n\n\nrevertFeatures\n, defaults to \nTrue\n, when set all features will be reverted when running a reset (drush only)\n\n\nconfigurationManagement\n, an array of configuration-labels to import on \nreset\n, defaults to \n['staging']\n. You can add command arguments for drush, e.g. \n['staging', 'dev --partial']\n\n\ndisableKnownHosts\n, \nuseShell\n and \nusePty\n see section \nother\n\n\ndatabase\n the database-credentials the \ninstall\n-tasks uses when installing a new installation.\n\n\nname\n the database name\n\n\nhost\n the database host\n\n\nuser\n the database user\n\n\npass\n the password for the database user\n\n\nprefix\n the optional table-prefix to use\n\n\n\n\n\n\nsshTunnel\n Fabalicious supports SSH-Tunnels, that means it can log in into another machine and forward the access to the real host. This is handy for dockerized installations, where the ssh-port of the docker-instance is not public. \nsshTunnel\n needs the following informations\n\n\nbridgeHost\n: the host acting as a bridge.\n\n\nbridgeUser\n: the ssh-user on the bridge-host\n\n\nbridgePort\n: the port to connect to on the bridge-host\n\n\nlocalPort\n: the local port which gets forwarded to the \ndestPort\n. If \nlocalPort\n is omitted, the ssh-port of the host-configuration is used. If the host-configuration does not have a port-property a random port is used.\n\n\ndestHost\n: the destination host to forward to\n\n\ndestHostFromDockerContainer\n: if set, the docker's Ip address is used for destHost. This is automatically set when using a \ndocker\n-configuration, see there.\n\n\ndestPort\n: the destination port to forward to\n\n\n\n\n\n\ndocker\n for all docker-relevant configuration. \nconfiguration\n and \nname\n are the only required keys, all other are optional and used by the docker-tasks.\n\n\nconfiguration\n should contain the key of the dockerHost-configuration in \ndockerHosts\n\n\nname\n contains the name of the docker-container. This is needed to get the IP-address of the particular docker-container when using ssh-tunnels (see above).\n\n\n\n\n\n\n\n\ndockerHosts\n\n\ndockerHosts\n is similar structured as the \nhosts\n-entry. It's a keyed lists of hosts containing all necessary information to create a ssh-connection to the host, controlling the docker-instances, and a list of tasks, the user might call via the \ndocker\n-command. See the \ndocker\n-entry for a more birds-eye-view of the concepts.\n\n\nHere's an example \ndockerHosts\n-entry:\n\n\ndockerHosts:\n  mbb:\n    runLocally: false\n    host: multibasebox.dev\n    user: vagrant\n    password: vagrant\n    port: 22\n    rootFolder: /vagrant\n    environment:\n      VHOST: %host.host%\n      WEBROOT: %host.rootFolder%\n    tasks:\n      logs:\n        - docker logs %host.docker.name%\n\n\n\n\nHere's a list of all possible entries of a dockerHosts-entry:\n\n\n\n\nrunLocally\n: if this is set to \ntrue\n, all docker-scripts are run locally, and not on a remote host.\n\n\nhost\n, \nuser\n, \nport\n and \npassword\n: all needed information to start a ssh-connection to that host. These settings are only respected, if \nrunLocally\n is set to \nfalse\n. \nport\n and \npassword\n are optional.\n\n\nenvironment\n a keyed list of environment-variables to set, when running one of the tasks. The replacement-patterns of \nscripts\n are supported, see there for more information.\n\n\ntasks\n a keyed list of commands to run for a given docker-subtask (similar to \nscripts\n). Note: these commands are running on the docker-host, not on the host. All replacement-patterns do work, and you can call even other tasks via \nexecute(\ntask\n, \nsubtask\n)\n e.g. \nexecute(docker, stop)\n See the \nscripts\n-section for more info.\n\n\n\n\nYou can use \ninheritsFrom\n to base your configuration on an existing one. You can add any configuration you may need and reference to that information from within your tasks via the replacement-pattern \n%dockerHost.keyName%\n e.g. \n%dockerHost.host%\n.\n\n\nYou can reference a specific docker-host-configuration from your host-configuration via\n\n\nhosts:\n  test:\n    docker:\n      configuration: mbb\n\n\n\n\ncommon\n\n\ncommon contains a list of commands, keyed by task and type which gets executed when the task is executed.\n\n\nExample:\n\n\ncommon:\n  reset:\n    dev:\n      - echo \nrunning reset on a dev-instance\n\n    stage:\n      - echo \nrunning reset on a stage-instance\n\n    prod:\n      - echo \nrunning reset on a prod-instance\n\n  deployPrepare:\n    dev:\n      - echo \npreparing deploy on a dev instance\n\n  deploy:\n    dev:\n      - echo \ndeploying on a dev instance\n\n  deployFinished:\n    dev:\n      - echo \nfinished deployment on a dev instance\n\n\n\n\n\nThe first key is the task-name (\nreset\n, \ndeploy\n, ...), the second key is the type of the installation (\ndev\n, \nstage\n, \nprod\n, \ntest\n). Every task is prepended by a prepare-stage and appended by a finished-stage, so you can call scripts before and after an actual task. You can even run other scripts via the \nexecute\n-command, see the \nscripts\n-section.\n\n\nscripts\n\n\nA keyed list of available scripts. This scripts may be defined globally (on the root level) or on a per host-level. The key is the name of the script and can be executed via\n\n\nfab config:\nconfiguration\n script:\nkey\n\n\n\n\n\nA script consists of an array of commands which gets executed sequentially.\n\n\nAn example:\n\n\nscripts:\n  test:\n    - echo \nRunning script test\n\n  test2:\n    - echo \nRunning script test2 on %host.config_name%\n    - execute(script, test)\n\n\n\n\nScripts can be defined on a global level, but also on a per host-level.\n\n\nYou can declare default-values for arguments via a slightly modified syntax:\n\n\nscripts:\n  defaultArgumentTest:\n    defaults:\n      name: Bob\n    script:\n      - echo \nHello %arguments.name%\n\n\n\n\n\nRunning the script via \nfab config:mbb script:defaultArgumentTest,name=\"Julia\"\n will show \nHello Julia\n. Running \nfab config:mbb script:defaultArgumentTest\n will show \nHello Bob\n.\n\n\nFor more information see the main scripts section below.\n\n\nother\n\n\n\n\ndeploymentModule\n name of the deployment-module the drush-method enables when doing a deploy\n\n\nusePty\n defaults to true, set it to false when you can't connect to specific hosts.\n\n\nuseShell\n defaults to true, set it to false, when you can't connect to specific hosts.\n\n\ndisableKnownHosts\n defaults to false, set it too true, if you trust every host\n\n\ngitOptions\n a keyed list of options to apply to a git command. Currently only pull is supported. If your git-version does not support \n--rebase\n you can disable it via an empty array: \npull: []\n\n\nsqlSkipTables\n a list of table-names drush should omit when doing a backup.\n\n\nconfigurationManagement\n a list of configuration-labels to import on \nreset\n. This defaults to \n['staging']\n and may be overridden on a per-host basis. You can add command arguments to the the configuration label.\n\n\n\n\nExample:\n\n\ndeploymentModule: my_deployment_module\nusePty: false\nuseShell: false\ngitOptions:\n  pull:\n    - --rebase\n    - --quiet\nsqlSkipTables:\n  - cache\n  - watchdog\n  - session\nconfigurationManagement:\n   - staging\n   - dev -- partial\n\n\n\n\nInheritance\n\n\nSometimes it make sense to extend an existing configuration or to include configuration from other places from the file-system or from remote locations. There's a special key \ninheritsFrom\n which will include the yaml found at the location and merge it with the data. This is supported for entries in \nhosts\n and \ndockerHosts\n and for the fabfile itself.\n\n\nIf a \nhost\n, a \ndockerHost\n or the fabfile itself has the key \ninheritsFrom\n, then the given key is used as a base-configuration. Here's a simple example:\n\n\nhosts:\n  default:\n    port: 22\n    host: localhost\n    user: default\n  example1:\n    inheritsFrom: default\n    port: 23\n  example2:\n    inheritsFrom: example1\n    user: example2\n\n\n\n\nexample1\n will store the merged configuration from \ndefault\n with the configuration of \nexample1\n. \nexample2\n is a merge of all three configurations: \nexample2\n with \nexample1\n with \ndefault\n.\n\n\nhosts:\n  example1:\n    port: 23\n    host: localhost\n    user: default\n  example2:\n    port: 23\n    host: localhost\n    user: example2\n\n\n\n\nYou can even reference external files to inherit from:\n\n\nhosts:\n  fileExample:\n    inheritsFrom: ./path/to/config/file.yaml\n  httpExapme:\n    inheritsFrom: http://my.tld/path/to/config_file.yaml\n\n\n\n\nThis mechanism works also for the fabfile.yaml / index.yaml itself, and is not limited to one entry:\n\n\nname: test fabfile\n\ninheritsFrom:\n  - ./mbb.yaml\n  - ./drupal.yaml\n\n\n\n\nScripts\n\n\nScripts are a powerful concept of fabalicious. There are a lot of places where scripts can be called. The \ncommon\n-section defines common scripts to be run for specific task/installation-type-configurations, docker-tasks are also scripts which you can execute via the docker-command. And you can even script fabalicious tasks and create meta-tasks.\n\n\nA script is basically a list of commands which get executed via shell on a remote machine. To stay independent of the host where the script is executed, fabalicious parsed the script before executing it and replaces given variables with their counterpart in the yams file.\n\n\nReplacement-patterns\n\n\nReplacement-Patterns are specific strings enclosed in \n%\ns, e.g. \n%host.port%\n, \n%dockerHost.rootFolder%\n or \n%arguments.name%\n.\n\n\nHere's a simple example;\n\n\nscript:\n  test:\n    - echo \nI am running on %host.config_name%\n\n\n\n\n\nCalling this script via\n\n\nfab config:mbb script:test\n\n\n\n\nwill show \nI am running on mbb\n.\n\n\n\n\nThe host-configuration gets exposes via the \nhost.\n-prefix, so \nport\n maps to \n%host.port%\n, etc.\n\n\nThe dockerHost-configuration gets exposed via the \ndockerHost\n-prefix, so \nrootFolder\n maps to \n%dockerHost.rootFolder%\n\n\nThe global configuration of the yams-file gets exposed to the \nsettings\n-prefix, so \nuuid\n gets mapped to `%settings.uuid%\n\n\nOptional arguments to the \nscript\n-taks get the \nargument\n-prefix, e.g. \n%arguments.name%\n. You can get all arguments via \n%arguments.combined%\n.\n\n\nYou can access hierarchical information via the dot-operator, e.g. \n%host.database.name%\n\n\n\n\nIf fabalicious detects a pattern it can't replace it will abort the execution of the script and displays a list of available replacement-patterns.\n\n\nInternal commands\n\n\nThere are currently 3 internal commands. These commands control the flow inside fabalicious:\n\n\n\n\nfail_on_error(1|0)\n If fail_on_error is set to one, fabalicious will exit if one of the script commands returns a non-zero return-code. When using \nfail_on_error(0)\n only a warning is displayed, the script will continue.\n\n\nexecute(task, subtask, arguments)\n execute a fabalicious task. For example you can run a deployment from a script via \nexecute(deploy)\n or stop a docker-container from a script via \nexecute(docker, stop)\n\n\nfail_on_missing_directory(directory, message)\n will print message \nmessage\n if the directory \ndirectory\n does not exist.\n\n\n\n\nTask-related scripts\n\n\nYou can add scripts to the \ncommon\n-section, which will called for any host. You can differentiate by task-name and host-type, e.g. create a script which gets called for the task \ndeploy\n and type \ndev\n.\n\n\nYou can even run scripts before or after a task is executed. Append the task with \nPrepare\n or \nFinished\n.\n\n\nYou can even run scripts for specific tasks and hosts. Just add your script with the task-name as its key.\n\n\nhost:\n  test:\n    deployPrepare:\n      - echo \nPreparing deploy for test\n\n    deploy:\n      - echo \nDeploying on test\n\n    deployFinished:\n      - echo \nDeployment finished for test\n\n\n\n\n\nThese scripts in the above examples gets executed only for the host \ntest\n and task \ndeploy\n.\n\n\nExamples\n\n\nA rather complex example scripting fabalicious.\n\n\nscripts:\n  runTests:\n    defaults:\n      branch: develop\n    script:\n      - execute(docker, start)\n      - execute(docker, waitForServices)\n      - execute(deploy, %arguments.branch%)\n      - execute(script, behatInstall)\n      - execute(script, behat, --profile=ci --format=junit --format=progress)\n      - execute(getFile, /var/www/_tools/behat/build/behat/default.xml, ./_tools/behat)\n      - execute(docker, stop)\n\n\n\n\nThis script will\n\n\n\n\nstart the docker-container,\n\n\nwait for it,\n\n\ndeploys the given branch,\n\n\nrun a script which will install behat,\n\n\nrun behat with some custom arguments,\n\n\ngets the result-file and copy it to a location,\n\n\nand finally stops the container.", 
            "title": "Structure of the configuration file"
        }, 
        {
            "location": "/configuration/#structure-of-the-configuration-file", 
            "text": "", 
            "title": "Structure of the configuration file"
        }, 
        {
            "location": "/configuration/#overview", 
            "text": "The configuration is fetched from the file  fabfile.yaml  and should have the followin structure:  name:  the project name \n\nneeds:\n  - list of methods\n\nrequires: 2.0\n\ndockerHosts:\n  docker1:\n    ...\n\nhosts:\n  host1:\n    ...  Here's the documentation of the supported and used keys:", 
            "title": "Overview"
        }, 
        {
            "location": "/configuration/#name", 
            "text": "The name of the project, it's only used for output.", 
            "title": "name"
        }, 
        {
            "location": "/configuration/#needs", 
            "text": "List here all needed methods for that type of project. Available methods are:   git  for deployments via git  ssh  drush7  for support of drupal-7 installations  drush8  for support fo drupal 8 installations  files  slack  for slack-notifications  docker  for docker-support  composer  for composer support  drupalconsole  for drupal-concole support   Example for drupal 7  needs:\n  - ssh\n  - git\n  - drush7\n  - files  Example for drupal 8 composer based and dockerized  needs:\n  - ssh\n  - git\n  - drush8\n  - composer\n  - docker\n  - files", 
            "title": "needs"
        }, 
        {
            "location": "/configuration/#requires", 
            "text": "The file-format of fabalicious changed over time. Set this to the lowest version of fabalicious which can handle the file. Should bei  2.0", 
            "title": "requires"
        }, 
        {
            "location": "/configuration/#hosts", 
            "text": "Hosts is a list of host-definitions which contain all needed data to connect to a remote host. Here's an example  hosts:\n  exampleHost:\n    host: example.host.tld\n    user: example_user\n    port: 2233\n    password: optionalPassword\n    type: dev\n    rootFolder: /var/www/public\n    gitRootFolder: /var/www\n    siteFolder: /sites/default\n    filesFolder: /sites/default/files\n    backupFolder: /var/www/backups\n    supportsInstalls: true|false\n    supportsCopyFrom: true|false\n    type: dev\n    branch: develop\n    docker:\n      ...\n    database:\n      ...\n    scripts:\n      ...\n    sshTunnel:\n      ..  You can get all host-information including the default values using the fabalicious command  about :  fab config:staging about  This will print all host configuration for the host  staging .  Here are all possible keys documented:   host ,  user ,  port  and optionally  password  is used to connect via SSH to the remote machine. Please make sure SSH key forwarding is enabled on your installation.  password  should only used as an exception.  type  defines the type of installation. Currently there are four types available:  dev  for dev-installations, they won't backup the databases on deployment  test  for test-installations, similar than  dev , no backups on deployments  stage  for staging-installations.  live  for live-installations. Some tasks can not be run on live-installations as  install  or as a target for  copyFrom \nThe main use-case is to run different scripts per type, see the  common -section.    branch  the name of the branch to use for deployments, they get ususally checked out and pulled from origin.  gitRootFolder  should be the base-folder, where the local git-repository is. (If not explicitely set, fabalicious uses the  rootFolder )  rootFolder   the web-root-folder of the installation, typically exposed to the public.  gitRootFolder   the folder, where the git-repository lies. Defaults to  rootFolder  composerRootFolder  the folder where the composer.json for the project is stored, defaults to  gitRootFolder .  backupFolder  the folder, where fabalicious should store its backups into  runLocally  if set to true, all commands are run on the local host, not on a remote host. Good for local development on linux or tools like MAMP.  siteFolder  is a drupal-specific folder, where the settings.php resides for the given installation. This allows to interact with multisites etc.  filesFolder  the path to the files-folder, where user-assets get stored and which should be backed up by the  files -method  tmpFolder  name of tmp-folder, defaults to  /tmp  supportsBackups  defaults to true, set to false, if backups are not supported  supportsZippedBackups  defaults to true. Set to false, if database-dumps shouldn't be zipped.  supportsInstalls  defaults to false, if set to true, the  install -task will run on that host.  supportsCopyFrom  defaults to false, if set to true, the host can be used as target for  copyFrom  ignoreSubmodules  defaults to true, set to false, if you don't want to update a projects' submodule on deploy.  revertFeatures , defaults to  True , when set all features will be reverted when running a reset (drush only)  configurationManagement , an array of configuration-labels to import on  reset , defaults to  ['staging'] . You can add command arguments for drush, e.g.  ['staging', 'dev --partial']  disableKnownHosts ,  useShell  and  usePty  see section  other  database  the database-credentials the  install -tasks uses when installing a new installation.  name  the database name  host  the database host  user  the database user  pass  the password for the database user  prefix  the optional table-prefix to use    sshTunnel  Fabalicious supports SSH-Tunnels, that means it can log in into another machine and forward the access to the real host. This is handy for dockerized installations, where the ssh-port of the docker-instance is not public.  sshTunnel  needs the following informations  bridgeHost : the host acting as a bridge.  bridgeUser : the ssh-user on the bridge-host  bridgePort : the port to connect to on the bridge-host  localPort : the local port which gets forwarded to the  destPort . If  localPort  is omitted, the ssh-port of the host-configuration is used. If the host-configuration does not have a port-property a random port is used.  destHost : the destination host to forward to  destHostFromDockerContainer : if set, the docker's Ip address is used for destHost. This is automatically set when using a  docker -configuration, see there.  destPort : the destination port to forward to    docker  for all docker-relevant configuration.  configuration  and  name  are the only required keys, all other are optional and used by the docker-tasks.  configuration  should contain the key of the dockerHost-configuration in  dockerHosts  name  contains the name of the docker-container. This is needed to get the IP-address of the particular docker-container when using ssh-tunnels (see above).", 
            "title": "hosts"
        }, 
        {
            "location": "/configuration/#dockerhosts", 
            "text": "dockerHosts  is similar structured as the  hosts -entry. It's a keyed lists of hosts containing all necessary information to create a ssh-connection to the host, controlling the docker-instances, and a list of tasks, the user might call via the  docker -command. See the  docker -entry for a more birds-eye-view of the concepts.  Here's an example  dockerHosts -entry:  dockerHosts:\n  mbb:\n    runLocally: false\n    host: multibasebox.dev\n    user: vagrant\n    password: vagrant\n    port: 22\n    rootFolder: /vagrant\n    environment:\n      VHOST: %host.host%\n      WEBROOT: %host.rootFolder%\n    tasks:\n      logs:\n        - docker logs %host.docker.name%  Here's a list of all possible entries of a dockerHosts-entry:   runLocally : if this is set to  true , all docker-scripts are run locally, and not on a remote host.  host ,  user ,  port  and  password : all needed information to start a ssh-connection to that host. These settings are only respected, if  runLocally  is set to  false .  port  and  password  are optional.  environment  a keyed list of environment-variables to set, when running one of the tasks. The replacement-patterns of  scripts  are supported, see there for more information.  tasks  a keyed list of commands to run for a given docker-subtask (similar to  scripts ). Note: these commands are running on the docker-host, not on the host. All replacement-patterns do work, and you can call even other tasks via  execute( task ,  subtask )  e.g.  execute(docker, stop)  See the  scripts -section for more info.   You can use  inheritsFrom  to base your configuration on an existing one. You can add any configuration you may need and reference to that information from within your tasks via the replacement-pattern  %dockerHost.keyName%  e.g.  %dockerHost.host% .  You can reference a specific docker-host-configuration from your host-configuration via  hosts:\n  test:\n    docker:\n      configuration: mbb", 
            "title": "dockerHosts"
        }, 
        {
            "location": "/configuration/#common", 
            "text": "common contains a list of commands, keyed by task and type which gets executed when the task is executed.  Example:  common:\n  reset:\n    dev:\n      - echo  running reset on a dev-instance \n    stage:\n      - echo  running reset on a stage-instance \n    prod:\n      - echo  running reset on a prod-instance \n  deployPrepare:\n    dev:\n      - echo  preparing deploy on a dev instance \n  deploy:\n    dev:\n      - echo  deploying on a dev instance \n  deployFinished:\n    dev:\n      - echo  finished deployment on a dev instance   The first key is the task-name ( reset ,  deploy , ...), the second key is the type of the installation ( dev ,  stage ,  prod ,  test ). Every task is prepended by a prepare-stage and appended by a finished-stage, so you can call scripts before and after an actual task. You can even run other scripts via the  execute -command, see the  scripts -section.", 
            "title": "common"
        }, 
        {
            "location": "/configuration/#scripts", 
            "text": "A keyed list of available scripts. This scripts may be defined globally (on the root level) or on a per host-level. The key is the name of the script and can be executed via  fab config: configuration  script: key   A script consists of an array of commands which gets executed sequentially.  An example:  scripts:\n  test:\n    - echo  Running script test \n  test2:\n    - echo  Running script test2 on %host.config_name%\n    - execute(script, test)  Scripts can be defined on a global level, but also on a per host-level.  You can declare default-values for arguments via a slightly modified syntax:  scripts:\n  defaultArgumentTest:\n    defaults:\n      name: Bob\n    script:\n      - echo  Hello %arguments.name%   Running the script via  fab config:mbb script:defaultArgumentTest,name=\"Julia\"  will show  Hello Julia . Running  fab config:mbb script:defaultArgumentTest  will show  Hello Bob .  For more information see the main scripts section below.", 
            "title": "scripts"
        }, 
        {
            "location": "/configuration/#other", 
            "text": "deploymentModule  name of the deployment-module the drush-method enables when doing a deploy  usePty  defaults to true, set it to false when you can't connect to specific hosts.  useShell  defaults to true, set it to false, when you can't connect to specific hosts.  disableKnownHosts  defaults to false, set it too true, if you trust every host  gitOptions  a keyed list of options to apply to a git command. Currently only pull is supported. If your git-version does not support  --rebase  you can disable it via an empty array:  pull: []  sqlSkipTables  a list of table-names drush should omit when doing a backup.  configurationManagement  a list of configuration-labels to import on  reset . This defaults to  ['staging']  and may be overridden on a per-host basis. You can add command arguments to the the configuration label.   Example:  deploymentModule: my_deployment_module\nusePty: false\nuseShell: false\ngitOptions:\n  pull:\n    - --rebase\n    - --quiet\nsqlSkipTables:\n  - cache\n  - watchdog\n  - session\nconfigurationManagement:\n   - staging\n   - dev -- partial", 
            "title": "other"
        }, 
        {
            "location": "/configuration/#inheritance", 
            "text": "Sometimes it make sense to extend an existing configuration or to include configuration from other places from the file-system or from remote locations. There's a special key  inheritsFrom  which will include the yaml found at the location and merge it with the data. This is supported for entries in  hosts  and  dockerHosts  and for the fabfile itself.  If a  host , a  dockerHost  or the fabfile itself has the key  inheritsFrom , then the given key is used as a base-configuration. Here's a simple example:  hosts:\n  default:\n    port: 22\n    host: localhost\n    user: default\n  example1:\n    inheritsFrom: default\n    port: 23\n  example2:\n    inheritsFrom: example1\n    user: example2  example1  will store the merged configuration from  default  with the configuration of  example1 .  example2  is a merge of all three configurations:  example2  with  example1  with  default .  hosts:\n  example1:\n    port: 23\n    host: localhost\n    user: default\n  example2:\n    port: 23\n    host: localhost\n    user: example2  You can even reference external files to inherit from:  hosts:\n  fileExample:\n    inheritsFrom: ./path/to/config/file.yaml\n  httpExapme:\n    inheritsFrom: http://my.tld/path/to/config_file.yaml  This mechanism works also for the fabfile.yaml / index.yaml itself, and is not limited to one entry:  name: test fabfile\n\ninheritsFrom:\n  - ./mbb.yaml\n  - ./drupal.yaml", 
            "title": "Inheritance"
        }, 
        {
            "location": "/configuration/#scripts_1", 
            "text": "Scripts are a powerful concept of fabalicious. There are a lot of places where scripts can be called. The  common -section defines common scripts to be run for specific task/installation-type-configurations, docker-tasks are also scripts which you can execute via the docker-command. And you can even script fabalicious tasks and create meta-tasks.  A script is basically a list of commands which get executed via shell on a remote machine. To stay independent of the host where the script is executed, fabalicious parsed the script before executing it and replaces given variables with their counterpart in the yams file.", 
            "title": "Scripts"
        }, 
        {
            "location": "/configuration/#replacement-patterns", 
            "text": "Replacement-Patterns are specific strings enclosed in  % s, e.g.  %host.port% ,  %dockerHost.rootFolder%  or  %arguments.name% .  Here's a simple example;  script:\n  test:\n    - echo  I am running on %host.config_name%   Calling this script via  fab config:mbb script:test  will show  I am running on mbb .   The host-configuration gets exposes via the  host. -prefix, so  port  maps to  %host.port% , etc.  The dockerHost-configuration gets exposed via the  dockerHost -prefix, so  rootFolder  maps to  %dockerHost.rootFolder%  The global configuration of the yams-file gets exposed to the  settings -prefix, so  uuid  gets mapped to `%settings.uuid%  Optional arguments to the  script -taks get the  argument -prefix, e.g.  %arguments.name% . You can get all arguments via  %arguments.combined% .  You can access hierarchical information via the dot-operator, e.g.  %host.database.name%   If fabalicious detects a pattern it can't replace it will abort the execution of the script and displays a list of available replacement-patterns.", 
            "title": "Replacement-patterns"
        }, 
        {
            "location": "/configuration/#internal-commands", 
            "text": "There are currently 3 internal commands. These commands control the flow inside fabalicious:   fail_on_error(1|0)  If fail_on_error is set to one, fabalicious will exit if one of the script commands returns a non-zero return-code. When using  fail_on_error(0)  only a warning is displayed, the script will continue.  execute(task, subtask, arguments)  execute a fabalicious task. For example you can run a deployment from a script via  execute(deploy)  or stop a docker-container from a script via  execute(docker, stop)  fail_on_missing_directory(directory, message)  will print message  message  if the directory  directory  does not exist.", 
            "title": "Internal commands"
        }, 
        {
            "location": "/configuration/#task-related-scripts", 
            "text": "You can add scripts to the  common -section, which will called for any host. You can differentiate by task-name and host-type, e.g. create a script which gets called for the task  deploy  and type  dev .  You can even run scripts before or after a task is executed. Append the task with  Prepare  or  Finished .  You can even run scripts for specific tasks and hosts. Just add your script with the task-name as its key.  host:\n  test:\n    deployPrepare:\n      - echo  Preparing deploy for test \n    deploy:\n      - echo  Deploying on test \n    deployFinished:\n      - echo  Deployment finished for test   These scripts in the above examples gets executed only for the host  test  and task  deploy .", 
            "title": "Task-related scripts"
        }, 
        {
            "location": "/configuration/#examples", 
            "text": "A rather complex example scripting fabalicious.  scripts:\n  runTests:\n    defaults:\n      branch: develop\n    script:\n      - execute(docker, start)\n      - execute(docker, waitForServices)\n      - execute(deploy, %arguments.branch%)\n      - execute(script, behatInstall)\n      - execute(script, behat, --profile=ci --format=junit --format=progress)\n      - execute(getFile, /var/www/_tools/behat/build/behat/default.xml, ./_tools/behat)\n      - execute(docker, stop)  This script will   start the docker-container,  wait for it,  deploys the given branch,  run a script which will install behat,  run behat with some custom arguments,  gets the result-file and copy it to a location,  and finally stops the container.", 
            "title": "Examples"
        }, 
        {
            "location": "/docker-integration/", 
            "text": "Docker integration\n\n\nTODO", 
            "title": "Docker integration"
        }, 
        {
            "location": "/docker-integration/#docker-integration", 
            "text": "TODO", 
            "title": "Docker integration"
        }, 
        {
            "location": "/local-overrides/", 
            "text": "Local overrides\n\n\nfabfile.local.yaml\n is used to override parts of your fabfile-configuration. If you run a fab-command the code will try to find the \nfabfile.local.yaml\n up to three folder levels up and merge the data with your fabfile.yaml.\n\n\nA small example:\n\n\nfabfile.local.yaml\n+ project\n  fabfile.yaml\n\n\n\n\nContents fo fabfile.yaml\n\n\nhosts:\n  local:\n    host: multibasebox.dev\n    port: 22\n    [...]\n\n\n\n\nContents of fabfile.local.yaml:\n\n\nhosts:\n  local:\n    host: localhost\n    port: 2222\n\n\n\n\nThis will override the \nhost\n and \nport\n settings of the \nlocal\n-configuration. With this technique you can alter an existing fabfile.yaml with local overrides. (In this example,  \nhost=localhost\n and \nport=2222", 
            "title": "Local overrides"
        }, 
        {
            "location": "/local-overrides/#local-overrides", 
            "text": "fabfile.local.yaml  is used to override parts of your fabfile-configuration. If you run a fab-command the code will try to find the  fabfile.local.yaml  up to three folder levels up and merge the data with your fabfile.yaml.  A small example:  fabfile.local.yaml\n+ project\n  fabfile.yaml  Contents fo fabfile.yaml  hosts:\n  local:\n    host: multibasebox.dev\n    port: 22\n    [...]  Contents of fabfile.local.yaml:  hosts:\n  local:\n    host: localhost\n    port: 2222  This will override the  host  and  port  settings of the  local -configuration. With this technique you can alter an existing fabfile.yaml with local overrides. (In this example,   host=localhost  and  port=2222", 
            "title": "Local overrides"
        }, 
        {
            "location": "/extending-fabalicious/", 
            "text": "Extending fabalicious\n\n\nYou can write custom tasks and methods in python and use it from inside fabalicious.\n\n\nRequirements\n\n\nYou need the python library \nyapsy\n, install it via\n\n\npip install yapsy\n\n\n\n\nDiscovery of plugins\n\n\nThe plugin-resolver will look into the following folders to find tasks and methods:\n\n\nproject_folder\n/.fabalicious/plugins\n\nuser-folder\n/.fabalicious/plugins\n\nfabalicious-folder\n/plugins\n\n\n\n\nStructure of a plugin\n\n\nA plugin consists of 2 files, an info-file \nplugin\n.yapsy-plugin\n and the implementation at \nplugin\n.py\n\n\nA custom task\n\n\nHere's an example for a custom task:\n\n\nfoo.yapsy-plugin:\n\n\n[Core]\nName = Foo\nModule = foo\n\n[Documentation]\nAuthor = Shibin Das\nVersion = 0.1\nWebsite = http://www.factorial.io\nDescription = Foo Plugin\n\n\n\n\nfoo.py:\n\n\nimport logging\nlog = logging.getLogger('fabric.fabalicious.foo')\nfrom lib.plugins.task import ITaskPlugin\n\nclass Foo(ITaskPlugin):\n  aliases = ['foo','foobar']\n  def run(self):\n    log.info('Foobar runs...')\n\n\n\n\nCustom tasks need to inherit from \nITaskPlugin\n and implement the \nrun\n-method.\n\n\nA custom method\n\n\nHere's an example of a custom method:\n\n\nbar.yapsy-plugin:\n\n\n[Core]\nName = bar\nModule = bar\n\n[Documentation]\nAuthor = Stephan Huber\nVersion = 0.1\nWebsite = http://www.factorial.io\nDescription = Bar method\n\n\n\n\nbar.py\n\n\nimport logging\nlog = logging.getLogger('fabric.fabalicious.bar')\nfrom lib.plugins.method import IMethodPlugin\n\nfrom fabric.api import *\nfrom lib import configuration\nfrom lib.utils import validate_dict\nfrom lib.configuration import data_merge\n\nclass BarMethod(IMethodPlugin):\n  @staticmethod\n  def supports(methodName):\n    return methodName == 'bar'\n\n  def preflight(self, task, config, **kwargs):\n    log.info('bar is preflighting task %s' % task)\n\n\n\n\nThe custom method needs to inherit from \nIMethodPlugin\n and must implement the static method \nsupports\n. Have a look into the \nBaseMethod\n-class or any other method to get an idea how to implement your custom method.\n\n\nTo use your custom method, just add its name as a \nneeds\n in fabfile.yaml, e.g.\n\n\nneeds:\n  - git\n  - ssh\n  - bar", 
            "title": "Extending fabalicious"
        }, 
        {
            "location": "/extending-fabalicious/#extending-fabalicious", 
            "text": "You can write custom tasks and methods in python and use it from inside fabalicious.", 
            "title": "Extending fabalicious"
        }, 
        {
            "location": "/extending-fabalicious/#requirements", 
            "text": "You need the python library  yapsy , install it via  pip install yapsy", 
            "title": "Requirements"
        }, 
        {
            "location": "/extending-fabalicious/#discovery-of-plugins", 
            "text": "The plugin-resolver will look into the following folders to find tasks and methods:  project_folder /.fabalicious/plugins user-folder /.fabalicious/plugins fabalicious-folder /plugins", 
            "title": "Discovery of plugins"
        }, 
        {
            "location": "/extending-fabalicious/#structure-of-a-plugin", 
            "text": "A plugin consists of 2 files, an info-file  plugin .yapsy-plugin  and the implementation at  plugin .py", 
            "title": "Structure of a plugin"
        }, 
        {
            "location": "/extending-fabalicious/#a-custom-task", 
            "text": "Here's an example for a custom task:", 
            "title": "A custom task"
        }, 
        {
            "location": "/extending-fabalicious/#fooyapsy-plugin", 
            "text": "[Core]\nName = Foo\nModule = foo\n\n[Documentation]\nAuthor = Shibin Das\nVersion = 0.1\nWebsite = http://www.factorial.io\nDescription = Foo Plugin", 
            "title": "foo.yapsy-plugin:"
        }, 
        {
            "location": "/extending-fabalicious/#foopy", 
            "text": "import logging\nlog = logging.getLogger('fabric.fabalicious.foo')\nfrom lib.plugins.task import ITaskPlugin\n\nclass Foo(ITaskPlugin):\n  aliases = ['foo','foobar']\n  def run(self):\n    log.info('Foobar runs...')  Custom tasks need to inherit from  ITaskPlugin  and implement the  run -method.", 
            "title": "foo.py:"
        }, 
        {
            "location": "/extending-fabalicious/#a-custom-method", 
            "text": "Here's an example of a custom method:", 
            "title": "A custom method"
        }, 
        {
            "location": "/extending-fabalicious/#baryapsy-plugin", 
            "text": "[Core]\nName = bar\nModule = bar\n\n[Documentation]\nAuthor = Stephan Huber\nVersion = 0.1\nWebsite = http://www.factorial.io\nDescription = Bar method", 
            "title": "bar.yapsy-plugin:"
        }, 
        {
            "location": "/extending-fabalicious/#barpy", 
            "text": "import logging\nlog = logging.getLogger('fabric.fabalicious.bar')\nfrom lib.plugins.method import IMethodPlugin\n\nfrom fabric.api import *\nfrom lib import configuration\nfrom lib.utils import validate_dict\nfrom lib.configuration import data_merge\n\nclass BarMethod(IMethodPlugin):\n  @staticmethod\n  def supports(methodName):\n    return methodName == 'bar'\n\n  def preflight(self, task, config, **kwargs):\n    log.info('bar is preflighting task %s' % task)  The custom method needs to inherit from  IMethodPlugin  and must implement the static method  supports . Have a look into the  BaseMethod -class or any other method to get an idea how to implement your custom method.  To use your custom method, just add its name as a  needs  in fabfile.yaml, e.g.  needs:\n  - git\n  - ssh\n  - bar", 
            "title": "bar.py"
        }, 
        {
            "location": "/contribute/", 
            "text": "Contributing to Fabalicious\n\n\nIf you get stuck at any point you can create a \nticket on GitHub\n.\n\n\nContributing to development\n\n\n@TODO\n\n\nImproving Documenation\n\n\n@TODO\n\n\n\n\nTip\n\n\nTo edit existing pages, use the \nEdit on GitHub\n link on the top right corner of the page.\n\n\nTo add a new page to documentation please follow \nthe guideline provided by MKdocs\n to add new page and link them within the documentation.\n\n\n\n\n\n\nNote\n\n\nThis document is build using \nMkDocs\n and served using \nGitHub Pages\n\n\n\n\nInstall MkDocs\n.\n\n\nClone \nthe repo\n locally and switch to \ndevelop\n branch.\n\n\nUsing Terminal, navigate to \n/docs\n folder.\n\n\nRun \nmike deploy \nversion-number\n\n\n\n\n\n\nResources\n\n\n\n\nWriting your docs in MKdocs", 
            "title": "Contributing to Fabalicious"
        }, 
        {
            "location": "/contribute/#contributing-to-fabalicious", 
            "text": "If you get stuck at any point you can create a  ticket on GitHub .", 
            "title": "Contributing to Fabalicious"
        }, 
        {
            "location": "/contribute/#contributing-to-development", 
            "text": "@TODO", 
            "title": "Contributing to development"
        }, 
        {
            "location": "/contribute/#improving-documenation", 
            "text": "@TODO   Tip  To edit existing pages, use the  Edit on GitHub  link on the top right corner of the page.  To add a new page to documentation please follow  the guideline provided by MKdocs  to add new page and link them within the documentation.    Note  This document is build using  MkDocs  and served using  GitHub Pages   Install MkDocs .  Clone  the repo  locally and switch to  develop  branch.  Using Terminal, navigate to  /docs  folder.  Run  mike deploy  version-number", 
            "title": "Improving Documenation"
        }, 
        {
            "location": "/contribute/#resources", 
            "text": "Writing your docs in MKdocs", 
            "title": "Resources"
        }, 
        {
            "location": "/changelog/", 
            "text": "Changelog\n\n\n2.4.1\n\n\nnew\n\n\n\n\nnew option \nreplaceSettingsFile\n which defaults to true. If set to false the \ninstall\n-task will not create a new settings.php-file.\n\n\nFor docker tasks support \nPrepare\n and \nFinished\n-tasks. If you want to run something before the \nrun\n-task, just add a \nrunPrepare\n-task.\ntasks:\n  runPrepare:\n    - echo \"Called before the run task\"\n  runFinished:\n    - echo \"Run task is finished\"\n\n\n\n\n\n\n\n2.4.0\n\n\nnew\n\n\n\n\n\n\nnew section in fabfile.yaml called \nblueprints\n. This section allows the usage of a given sets of blueprints as normal config. That means, they will get listed and work with autocomplete\n\n\nblueprints:\n  - configName: \nname of blueprint-config\n\n    variants:\n      - variantA\n      - variantB\n      - variantC\n\n\n\nThe list of configs will include the three variants applied with the blueprint \nname of blueprint-config\n This will allow a config inherited from a blueprint with a given variant.\n\n\n\n\n\n\nnew plugin-discovery via \nyapsy\n, it allows you to add custom tasks and methods to your project, or to your user-folder.\n\n\nThe plugin-resolver will look into the following folders to find tasks and methods:\n\n\nproject_folder\n/.fabalicious/plugins\n\nuser-folder\n/.fabalicious/plugins\n\nfabalicious-folder\n/tasks\n\n\n\n\n\n\n\nchanged\n\n\n\n\nmethods are now responsible to provide their default global settings via the static \ngetGlobalSettings\n-method.\n\n\n\n\n2.3.1\n\n\nnew\n\n\n\n\nnew task \nlogLevel\n: used to change the default logging level of the program.\n\n\n\n\nchanged\n\n\n\n\nRefactored output logging to use python logging library.\n\n\n\n\n2.3.0\n\n\nnew\n\n\n\n\nnew task \nsshCommand\n: it will print out a ssh command to log into a remote instance. With some shell-magic you can streamline it into a single shell-command. This command will not have the downsides of the \nssh\n-command e.g. the lagging shell.\n\n\nnew task \ninstallFrom\n which will do a install-task and a copyFrom afterwards. It will run the reset-task only after the copyFrom, so performance is better\n\n\nnew task \ngetFilesDump\n which will tar all files in the \nfilesFolder\n into a tar and download it to the local computer.\n\n\ndockerKeyFile\n, \ndockerAuthorizedKeyFile\n and \ndockerKnownHostsFile\n can now be loaded from http(s)\n\n\nnew settings \nrevertFeatures\n, which defaults to \nTrue\n -- if set to False, features will not be reverted.\n\n\n\n\nchanged\n\n\n\n\ncreateApp\n will run the composer-task inside the docker-container and after spinning up the containers. This will prevent some versions-mismatches of php between the host and the container.\n\n\ncreateApp\n will skip the \nreset\n-task if it was called with a \ncopyFrom\n-argument.\n\n\n\n\n2.2.5\n\n\nnew\n\n\n\n\n\n\nnew task \noffline\n, this task will disable remote configuration files and try using already cached versions. Use as the first task\n\n\n$ fab offline config:my_config about\n\n\n\n\n\n\n\nSupport for \nmodules_enabled.txt\n and \nmodules_disabled.txt\n. Listed modules in these files get enabled or disabled when doing a reset (drush7 and drush8) You can add configuration to ignore some of the modules:\n\n\nmodulesEnabledIgnore:\n  - coffee\n  - some_other_module\nmodulesDisabledIgnore:\n  - devel\n\n\n\nThese settings can be part of the global configuration or of the host configuration.\n\n\n\n\n\n\nAdd a new optional per-host-setting to set the composer root folder called \ncompserRootFolder\n, if not present the \ngitRootFolder\n gets used\n\n\n\n\nYou can specify now the locale, distribution and other options for the drush install-task. These settings may be global or a per host-setting.\ninstallOptions:\n  distribution: thunder\n  locale: de\n  options: \"thunder_module_configure_form.install_modules_thunder_demo=NULL\"\n\n\n\n\n\n\n\n2.2.0\n\n\nnew\n\n\n\n\nwhen running \ncomposer install\n fabalicious will create automatically a symlink to \nfabfile.py\n.\n\n\nnew option \nskipCreateDatabase\n in \ndatabase\n, if set to \nTrue\n no database will be created.\n\n\nexecutables can now have variables, they will get expanded beforehand (for an example see next line)\n\n\n\n\nexecutables have a new special variables called \n%arguments%\n which contains the arguments for an executable, here's an example:\n\n\nexecutables:\n  drush: docker exec -itu drupal %host.docker.name% bash -c 'cd %host.docker.siteFolder% \n drush %arguments%'\n\n\n\n\n\n\n\nsupport for custom executable paths has been added. This will help getting specific hosting-environments to corporate nicely with fabalicious.\n\n\nTo change the standard executable-name and path, add an \nexecutables\n-section to your host or your global settings:\n\n\nexecutables:\n  drush: /opt/bin/local/drush\n  git: /usr/local/bin/git\n\n\n\nIt will also work for your custom scripts, but only if you use the newly introduced \"shebang\"-syntax for executables. Instead of writing \ndrush\n prefix the command with \n#!\n, e.g. \n!#drush\n:\n\n\nscript:\n  example:\n    - cd %host.siteFolder%; #!drush cc all\n    - cd %host.gitRootFolder%; #!npm install\n\n\n\nThis will also work for custom executables (in the example \nnpm\n), but do not forget to add the executable to the \nexecutables\n-section.\n\n\n\n\n\n\n2.1.0\n\n\nnew\n\n\n\n\n\n\nnew task \ncompletions\n which will help to get completions in the shell working. Currently only for the \nfish\n-shell.\n\n\ncomplete -c fab -e -f\ncomplete -c fab -f -a \"(fab completions:type=fish)\"\n\n\n\n\n\n\n\nnew tasks \ncreateApp\n and \ndestroyApp\n. Needs docker and is not available on local. \ncreateApp\n will clone the repository, start the docker-container and install the app. \ndestroyApp\n will destroy the app and remove any containers.\n\n\n\n\nnew task \nblueprint\n. This task will load a template from the fabfile.yaml, do some pattern replacement and use the resulting data as the current configuration. With this task it is easy to create dynamic configurations e.g. for CI-integration or similar scenarios.\n\n\nrunLocally\n for dockerHosts: if set to true for a given dockerHost-configuration, the commands get executed locally.\n\n\nrunLocally\n for hosts: if set to true for a given host-configuration, all commands are run locally.\n\n\nnew task \ndoctor\n. This will try to do all necessary connections and will inform of any problems. Good for troubleshooting.\n\n\nfabfile.local.yaml will override existing fabfile.yaml-configuration. the file may reside up to three folders above the projects fabfile. See the readme for more info\n\n\nsupport for platform.sh\n\n\n\n\nchanged\n\n\n\n\nfabfile.yaml.lock is not used anymore. To support offline-mode, fabalicious will store all remote files in the \n~/.fabalicious\n folder. If loading a remote resource fails, fabalicious will use the local cached version of that file.\n\n\ndrush8: configurationManagement is completely configurable, e.g. to run a script, add this to your fabfile.yaml\nconfigurationManagement:\n  staging:\n    - execute(script, config-import)\n\n\n\n\n\n\n\n2.0.0\n\n\nnew\n\n\n\n\n\n\nyou can now specify what features you need. The following features are available: \ncomposer\n, \ndocker\n, \ndrush7\n, \ndrush8\n, \ngit\n, \nssh\n, \nfiles\n, \nslack\n, \ndrupalconsole\n. You specify your needs in the fabfile with the \nneeds\n-key. You can declare this globally and/or per host.\n\n\nneeds:\n  - git\n  - drush8\n  - composer\n  - slack\n  - ssh\n  - files\n\n\nneeds\n defaults to \ngit\n, \nssh\n, \ndrush7\n and \nfiles\n if not set explicitly.\n\n\n\n\n\n\nnew key \nenvironment\n, you can declare a list of environment-variables in \nhosts\n and \ndockerHosts\n which get exposed to the running scripts. You can even use the known replacement-patterns available to scripts\n\n\nenvironment:\n  - ROOT_FOLDER: \"%dockerHost.rootFolder%/%host.docker.projectFolder%\"\n  - TYPE: \"%host.type%\n\n\n\n\n\n\nthe replacement-patterns already available for docker-scripts are now available for all scripts.\n\n\n\n\n\n\nevery task may have a script, which gets called, when the task gets executed. There are three stages for every task available: \ntask\nPrepare\n, \ntask\n and \ntask\nFinished\n. Here's an example for the deploy-task:\n\n\ndeployPrepare:\n  - echo \"Preparing deployment \u2026\"\ndeploy:\n  - echo \"Deploying \u2026\"\ndeployFinished:\n  - echo \"Finished with deployment.\"\n\n\n\n\n\n\nYou can now add custom scripts to your fabfile and run it via the \nscript\n-task. Declare your scripts on the root level. Here's an example:\n\n\nscripts:\n testScript:\n   - echo \"This is a test-script\u2026\"\n\n\nNow you can run the script via\n\n\nfab config:\nconfig\n script:testScript\n\n\nIf you need default arguments, you can split your script-declaration as follows:\n\n\nscripts:\n  hello:\n    defaults:\n      name: world\n    script:\n      - echo \"hello %arguments.name%\"\n\n\nRunning \nfab config:\nconfig\n script:hello\n will print \"hello world\". Running \nfab config:\nconfig\n script:hello,name=\"universum\"\n will print \"hello universum\".\n\n\n\n\n\n\nyou can specify a branch when running the deploy-task: \ndeploy:\nbranchname\n. This will override the branch temporary.\n\n\n\n\n\n\nYou can now specify port and the public port for the startRemoteAccess subtask: To create a tunnel to the mysql-server you can use\n\n\nfab config:\nyour-config\n docker:startRemoteAccess,port=3306,publicPort=33060\n\n* You can run other tasks from  within your scripts, use the reserved keyword \nexecute\n\n\ntestScript:\n  - execute(deploy)\n  - execute(docker, start)\n\n\n\n\n\n\nIt should be easier to extend fabalicious to support other hosting environments or applications. You can now add custom scripts to your fabalicious file and call them when running a specific task. Or you can add a new custom method to the source, which gets called when running a specific task. You can even extend existing methods and register them under a different name. (Needs more documentation.)\n\n\n\n\n\n\nNew task \ndrupalconsole:\ncommand\n. Runs the Drupal Console inside your container, on your host. If \ncommand\n is \ninstall\n drupal-console gets installed on that environment. The Drupal Console does similar things like drush, but there's currently no support to \"deploy\" via the drupal console.\n\n\n\n\n\n\nchanged\n\n\n\n\nscript-replacements are now prefixed by \nhost\n and \ndockerHost\n. You\u2019ll get a list of available replacements if fabalicious can\u2019t resolve all replacements successfully.\n\n\nAll declared yaml-variables are exposed to the script. You can access sub-dictionaries via the dot-syntax, e.g. \nhost.docker.name\n.\n\n\nThe task \nwaitForServices\n is now part of the docker-method. Invoke it via \ndocker:waitForServices\n\n\nThe task \nstartRemoteAccess\n is now part of the docker-method. Invoke it via \ndocker:startRemoteAccess\n\n\nThe task \ncopySSHKeyToDocker\n is renamed to \ncopySSHKeys\nand is now part of the docker-method. Invoke it via \ndocker:copySSHKeys\n\n\n\n\nthe common-section of the fabfile.yaml has changed, you can specify a common script per \ntype\n, e.g.:\n\n\ncommon:\n  dev:\n    - echo \"dev\"\n  stage:\n    - echo \"stage\"\n  prod:\n    - echo \"prod\"\n\n\nYou can even use custom types, but \nprod\n is reserved for production-installations.\n\n\n\n\n\n\nunsupported\n\n\n\n\nuseForDevelopment\n is unsupported, use \ntype\n with value \ndev\n or \nstage\n\n\nhasDrush\n is unsupported, set your \nneeds\n accordingly.\n\n\nneedsComposer\n is unsupported, set your \nneeds\n accordingly.\n\n\nthe custom script-command \nrun_task\n is not supported anymore. Use \nexecute(\ntask-name\n)\n instead.\n\n\nthe task \nupdateDrupalCore\n is not ported over, not sure if it comes back.", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#241", 
            "text": "", 
            "title": "2.4.1"
        }, 
        {
            "location": "/changelog/#new", 
            "text": "new option  replaceSettingsFile  which defaults to true. If set to false the  install -task will not create a new settings.php-file.  For docker tasks support  Prepare  and  Finished -tasks. If you want to run something before the  run -task, just add a  runPrepare -task. tasks:\n  runPrepare:\n    - echo \"Called before the run task\"\n  runFinished:\n    - echo \"Run task is finished\"", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#240", 
            "text": "", 
            "title": "2.4.0"
        }, 
        {
            "location": "/changelog/#new_1", 
            "text": "new section in fabfile.yaml called  blueprints . This section allows the usage of a given sets of blueprints as normal config. That means, they will get listed and work with autocomplete  blueprints:\n  - configName:  name of blueprint-config \n    variants:\n      - variantA\n      - variantB\n      - variantC  The list of configs will include the three variants applied with the blueprint  name of blueprint-config  This will allow a config inherited from a blueprint with a given variant.    new plugin-discovery via  yapsy , it allows you to add custom tasks and methods to your project, or to your user-folder.  The plugin-resolver will look into the following folders to find tasks and methods:  project_folder /.fabalicious/plugins user-folder /.fabalicious/plugins fabalicious-folder /tasks", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#changed", 
            "text": "methods are now responsible to provide their default global settings via the static  getGlobalSettings -method.", 
            "title": "changed"
        }, 
        {
            "location": "/changelog/#231", 
            "text": "", 
            "title": "2.3.1"
        }, 
        {
            "location": "/changelog/#new_2", 
            "text": "new task  logLevel : used to change the default logging level of the program.", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#changed_1", 
            "text": "Refactored output logging to use python logging library.", 
            "title": "changed"
        }, 
        {
            "location": "/changelog/#230", 
            "text": "", 
            "title": "2.3.0"
        }, 
        {
            "location": "/changelog/#new_3", 
            "text": "new task  sshCommand : it will print out a ssh command to log into a remote instance. With some shell-magic you can streamline it into a single shell-command. This command will not have the downsides of the  ssh -command e.g. the lagging shell.  new task  installFrom  which will do a install-task and a copyFrom afterwards. It will run the reset-task only after the copyFrom, so performance is better  new task  getFilesDump  which will tar all files in the  filesFolder  into a tar and download it to the local computer.  dockerKeyFile ,  dockerAuthorizedKeyFile  and  dockerKnownHostsFile  can now be loaded from http(s)  new settings  revertFeatures , which defaults to  True  -- if set to False, features will not be reverted.", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#changed_2", 
            "text": "createApp  will run the composer-task inside the docker-container and after spinning up the containers. This will prevent some versions-mismatches of php between the host and the container.  createApp  will skip the  reset -task if it was called with a  copyFrom -argument.", 
            "title": "changed"
        }, 
        {
            "location": "/changelog/#225", 
            "text": "", 
            "title": "2.2.5"
        }, 
        {
            "location": "/changelog/#new_4", 
            "text": "new task  offline , this task will disable remote configuration files and try using already cached versions. Use as the first task  $ fab offline config:my_config about    Support for  modules_enabled.txt  and  modules_disabled.txt . Listed modules in these files get enabled or disabled when doing a reset (drush7 and drush8) You can add configuration to ignore some of the modules:  modulesEnabledIgnore:\n  - coffee\n  - some_other_module\nmodulesDisabledIgnore:\n  - devel  These settings can be part of the global configuration or of the host configuration.    Add a new optional per-host-setting to set the composer root folder called  compserRootFolder , if not present the  gitRootFolder  gets used   You can specify now the locale, distribution and other options for the drush install-task. These settings may be global or a per host-setting. installOptions:\n  distribution: thunder\n  locale: de\n  options: \"thunder_module_configure_form.install_modules_thunder_demo=NULL\"", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#220", 
            "text": "", 
            "title": "2.2.0"
        }, 
        {
            "location": "/changelog/#new_5", 
            "text": "when running  composer install  fabalicious will create automatically a symlink to  fabfile.py .  new option  skipCreateDatabase  in  database , if set to  True  no database will be created.  executables can now have variables, they will get expanded beforehand (for an example see next line)   executables have a new special variables called  %arguments%  which contains the arguments for an executable, here's an example:  executables:\n  drush: docker exec -itu drupal %host.docker.name% bash -c 'cd %host.docker.siteFolder%   drush %arguments%'    support for custom executable paths has been added. This will help getting specific hosting-environments to corporate nicely with fabalicious.  To change the standard executable-name and path, add an  executables -section to your host or your global settings:  executables:\n  drush: /opt/bin/local/drush\n  git: /usr/local/bin/git  It will also work for your custom scripts, but only if you use the newly introduced \"shebang\"-syntax for executables. Instead of writing  drush  prefix the command with  #! , e.g.  !#drush :  script:\n  example:\n    - cd %host.siteFolder%; #!drush cc all\n    - cd %host.gitRootFolder%; #!npm install  This will also work for custom executables (in the example  npm ), but do not forget to add the executable to the  executables -section.", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#210", 
            "text": "", 
            "title": "2.1.0"
        }, 
        {
            "location": "/changelog/#new_6", 
            "text": "new task  completions  which will help to get completions in the shell working. Currently only for the  fish -shell.  complete -c fab -e -f\ncomplete -c fab -f -a \"(fab completions:type=fish)\"    new tasks  createApp  and  destroyApp . Needs docker and is not available on local.  createApp  will clone the repository, start the docker-container and install the app.  destroyApp  will destroy the app and remove any containers.   new task  blueprint . This task will load a template from the fabfile.yaml, do some pattern replacement and use the resulting data as the current configuration. With this task it is easy to create dynamic configurations e.g. for CI-integration or similar scenarios.  runLocally  for dockerHosts: if set to true for a given dockerHost-configuration, the commands get executed locally.  runLocally  for hosts: if set to true for a given host-configuration, all commands are run locally.  new task  doctor . This will try to do all necessary connections and will inform of any problems. Good for troubleshooting.  fabfile.local.yaml will override existing fabfile.yaml-configuration. the file may reside up to three folders above the projects fabfile. See the readme for more info  support for platform.sh", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#changed_3", 
            "text": "fabfile.yaml.lock is not used anymore. To support offline-mode, fabalicious will store all remote files in the  ~/.fabalicious  folder. If loading a remote resource fails, fabalicious will use the local cached version of that file.  drush8: configurationManagement is completely configurable, e.g. to run a script, add this to your fabfile.yaml configurationManagement:\n  staging:\n    - execute(script, config-import)", 
            "title": "changed"
        }, 
        {
            "location": "/changelog/#200", 
            "text": "", 
            "title": "2.0.0"
        }, 
        {
            "location": "/changelog/#new_7", 
            "text": "you can now specify what features you need. The following features are available:  composer ,  docker ,  drush7 ,  drush8 ,  git ,  ssh ,  files ,  slack ,  drupalconsole . You specify your needs in the fabfile with the  needs -key. You can declare this globally and/or per host.  needs:\n  - git\n  - drush8\n  - composer\n  - slack\n  - ssh\n  - files  needs  defaults to  git ,  ssh ,  drush7  and  files  if not set explicitly.    new key  environment , you can declare a list of environment-variables in  hosts  and  dockerHosts  which get exposed to the running scripts. You can even use the known replacement-patterns available to scripts  environment:\n  - ROOT_FOLDER: \"%dockerHost.rootFolder%/%host.docker.projectFolder%\"\n  - TYPE: \"%host.type%    the replacement-patterns already available for docker-scripts are now available for all scripts.    every task may have a script, which gets called, when the task gets executed. There are three stages for every task available:  task Prepare ,  task  and  task Finished . Here's an example for the deploy-task:  deployPrepare:\n  - echo \"Preparing deployment \u2026\"\ndeploy:\n  - echo \"Deploying \u2026\"\ndeployFinished:\n  - echo \"Finished with deployment.\"    You can now add custom scripts to your fabfile and run it via the  script -task. Declare your scripts on the root level. Here's an example:  scripts:\n testScript:\n   - echo \"This is a test-script\u2026\"  Now you can run the script via  fab config: config  script:testScript  If you need default arguments, you can split your script-declaration as follows:  scripts:\n  hello:\n    defaults:\n      name: world\n    script:\n      - echo \"hello %arguments.name%\"  Running  fab config: config  script:hello  will print \"hello world\". Running  fab config: config  script:hello,name=\"universum\"  will print \"hello universum\".    you can specify a branch when running the deploy-task:  deploy: branchname . This will override the branch temporary.    You can now specify port and the public port for the startRemoteAccess subtask: To create a tunnel to the mysql-server you can use  fab config: your-config  docker:startRemoteAccess,port=3306,publicPort=33060 \n* You can run other tasks from  within your scripts, use the reserved keyword  execute  testScript:\n  - execute(deploy)\n  - execute(docker, start)    It should be easier to extend fabalicious to support other hosting environments or applications. You can now add custom scripts to your fabalicious file and call them when running a specific task. Or you can add a new custom method to the source, which gets called when running a specific task. You can even extend existing methods and register them under a different name. (Needs more documentation.)    New task  drupalconsole: command . Runs the Drupal Console inside your container, on your host. If  command  is  install  drupal-console gets installed on that environment. The Drupal Console does similar things like drush, but there's currently no support to \"deploy\" via the drupal console.", 
            "title": "new"
        }, 
        {
            "location": "/changelog/#changed_4", 
            "text": "script-replacements are now prefixed by  host  and  dockerHost . You\u2019ll get a list of available replacements if fabalicious can\u2019t resolve all replacements successfully.  All declared yaml-variables are exposed to the script. You can access sub-dictionaries via the dot-syntax, e.g.  host.docker.name .  The task  waitForServices  is now part of the docker-method. Invoke it via  docker:waitForServices  The task  startRemoteAccess  is now part of the docker-method. Invoke it via  docker:startRemoteAccess  The task  copySSHKeyToDocker  is renamed to  copySSHKeys and is now part of the docker-method. Invoke it via  docker:copySSHKeys   the common-section of the fabfile.yaml has changed, you can specify a common script per  type , e.g.:  common:\n  dev:\n    - echo \"dev\"\n  stage:\n    - echo \"stage\"\n  prod:\n    - echo \"prod\"  You can even use custom types, but  prod  is reserved for production-installations.", 
            "title": "changed"
        }, 
        {
            "location": "/changelog/#unsupported", 
            "text": "useForDevelopment  is unsupported, use  type  with value  dev  or  stage  hasDrush  is unsupported, set your  needs  accordingly.  needsComposer  is unsupported, set your  needs  accordingly.  the custom script-command  run_task  is not supported anymore. Use  execute( task-name )  instead.  the task  updateDrupalCore  is not ported over, not sure if it comes back.", 
            "title": "unsupported"
        }
    ]
}